{"meta":{"title":"武田晴海","subtitle":"","description":"","author":"武田晴海","url":"https://wyryyds.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2023-04-02T06:32:25.487Z","updated":"2023-04-02T06:32:25.487Z","comments":true,"path":"archive.html","permalink":"https://wyryyds.github.io/archive.html","excerpt":"","text":""},{"title":"关于博主","date":"2023-09-11T14:36:11.288Z","updated":"2023-09-11T14:36:11.288Z","comments":true,"path":"about.html","permalink":"https://wyryyds.github.io/about.html","excerpt":"","text":"个人介绍很高兴认识你^O^,这里是小海！ 现就读于湖南工业大学计算机学院软件工程专业。目前正在学院双创中心游戏组进行游戏开发相关知识的学习。 我对游戏客户端，游戏AI，动画模拟等内容有着浓厚的兴趣。 以往经历 电魂网络 | 野蛮人大作战2：客户端开发实习 深圳拂曦科技 | 异度行者：客户端AI开发实习 我的作品 2023 CIGA Game Jam Ludum Dare 51 2022 Booom 创作赛 与我联系QQ：2245958498 邮箱：&#99;&#111;&#114;&#110;&#101;&#108;&#105;&#117;&#x73;&#x5f;&#104;&#x75;&#x74;&#64;&#111;&#117;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#x6f;&#x6d;"},{"title":"书籍阅读","date":"2023-04-12T14:26:41.481Z","updated":"2023-04-12T14:26:41.481Z","comments":true,"path":"donate.html","permalink":"https://wyryyds.github.io/donate.html","excerpt":"","text":"黄昏住雨 有夜来香 云雾懒惰 伏罩此江 五感通畅 而思想滞涩 ——《哑牛》 保持思考，不被同化，在我看来就是阅读的意义。 下面是我在大学之后看过的一些个人觉得还不错的书籍，有技术方向的也有杂书，会一直保持更新。 技术学习 一些好看的书"},{"title":"我的朋友","date":"2023-05-17T15:56:23.160Z","updated":"2023-05-17T15:56:23.159Z","comments":true,"path":"PY.html","permalink":"https://wyryyds.github.io/PY.html","excerpt":"","text":"一个人的生命 我认为一半是活在朋友中的 ——老舍《可爱的成都》"}],"posts":[{"title":"Destiny2拆解分析","slug":"Destiny2拆解分析","date":"2023-08-14T13:18:33.528Z","updated":"2023-10-15T10:12:42.525Z","comments":true,"path":"2023/08/14/Destiny2拆解分析/","link":"","permalink":"https://wyryyds.github.io/2023/08/14/Destiny2%E6%8B%86%E8%A7%A3%E5%88%86%E6%9E%90/","excerpt":"","text":"文章放在知乎：知乎链接 如果后面把视频嵌入修好了，再考虑移植罢（雾 视频的大小还是不对","categories":[{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/categories/Game-Design/"}],"tags":[{"name":"Destiny2","slug":"Destiny2","permalink":"https://wyryyds.github.io/tags/Destiny2/"},{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/tags/Game-Design/"}]},{"title":"UE5 Lyra全系统拆解分析","slug":"UE5-Lyra全系统拆解分析","date":"2023-08-06T12:36:22.150Z","updated":"2023-09-07T15:52:13.851Z","comments":true,"path":"2023/08/06/UE5-Lyra全系统拆解分析/","link":"","permalink":"https://wyryyds.github.io/2023/08/06/UE5-Lyra%E5%85%A8%E7%B3%BB%E7%BB%9F%E6%8B%86%E8%A7%A3%E5%88%86%E6%9E%90/","excerpt":"","text":"填完坑就补 References知乎：Lyra动画系统","categories":[{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/categories/UE5/"}],"tags":[{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/tags/UE5/"},{"name":"Lyra","slug":"Lyra","permalink":"https://wyryyds.github.io/tags/Lyra/"}]},{"title":"简析Unity下的游戏热更新技术","slug":"简析Unity下的游戏热更新技术","date":"2023-07-09T14:27:00.538Z","updated":"2023-08-14T14:07:07.139Z","comments":true,"path":"2023/07/09/简析Unity下的游戏热更新技术/","link":"","permalink":"https://wyryyds.github.io/2023/07/09/%E7%AE%80%E6%9E%90Unity%E4%B8%8B%E7%9A%84%E6%B8%B8%E6%88%8F%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF/","excerpt":"","text":"写完就填坑","categories":[{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/categories/Unity/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/tags/Unity/"},{"name":"xlua","slug":"xlua","permalink":"https://wyryyds.github.io/tags/xlua/"},{"name":"ILRuntime","slug":"ILRuntime","permalink":"https://wyryyds.github.io/tags/ILRuntime/"},{"name":"HyBridCLR，热更新","slug":"HyBridCLR，热更新","permalink":"https://wyryyds.github.io/tags/HyBridCLR%EF%BC%8C%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"对C#与C++中事件机制的解析","slug":"事件类型的解析","date":"2023-04-13T07:21:11.150Z","updated":"2023-04-18T11:01:40.647Z","comments":true,"path":"2023/04/13/事件类型的解析/","link":"","permalink":"https://wyryyds.github.io/2023/04/13/%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%90/","excerpt":"","text":"在对C++项目的学习中，也是慢慢接触到了C++中的事件机制。之前最早的博客里面也是有我大一曾经对C#中的委托与事件做的笔记，现在把两者重新放在一起进行比较讨论。 C#中的事件机制在提到C#中的Event时，有必要先认识一下C#的委托(delegate)： C#中的Delegate在C#中，委托是一种类，它包装了一个或者多个方法，并且允许以类似函数调用的方式来调用这些方法，类似C++中的函数指针。下面是委托的几种显式声明格式： 1.不含参数列表，使用void作为返回类型的委托定义与声明格式： public delegate void MyDelegate1(); public MyDelegate1 handler1 2.接受一个int类型参数，使用void作为返回类型的委托定义与声明格式 public delegate void MyDelegate2(int param); public MyDelegate2 handler2 3.接受一个int类型与一个string类型的参数，使用int作为返回类型的委托定义与声明格式： public delegate int MyDelegate3(int param1,string param2); public MyDelegate3 handler3 4.接受两个泛型参数，返回值为泛型的委托定义与声明格式： public delegate TResult MyDelegate4&lt;in T1, in T2, out TResult&gt;(T1 param1, T2 param2); public MyDelegate4&lt;int,string,int&gt; handler4 委托的声明方式远不止以上几种，他跟函数的声明一样的灵活，只需要加上delegate关键词即可。C#也内置了几种泛型委托提供了更简洁的委托声明方式，我们可以使用Action与Func简化上面的几种声明格式，其中第四种就是Func的一种定义： 1.不含参数列表，使用void作为返回类型的委托声明格式： public Action handler1; 2.接受一个int类型参数，使用void作为返回类型的委托声明格式 public Action&lt;int&gt; handler2; 3.接受一个int类型与一个string类型的参数，使用int作为返回类型的委托声明格式： public Func&lt;int,string,int&gt; handler3; 4.接受两个泛型参数，返回值为泛型的委托声明格式： public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 param1,T2 param2); public Func&lt;int,string,int&gt; handler4; C#规定，Action用来声明无返回值类型委托，Func用来声明有返回值委托。在实际开发中，我们都应该尽量使用这种方式来对委托进行声明，他们的优点显而易见，一是避免了显式委托声明的繁琐，二是对委托是否具有返回值进行了界定，非常的清晰。 对上面第一种情况的委托进行使用： 12345678910111213141516171819//声明委托public Action handler1;//无参数，void返回类型的函数声明public void ConsoleString()&#123; Console.Writeline(&quot;调用handler1&quot;);&#125;//将方法添加到委托中。handler1 += ConsoleString;//调用委托//handler1();//显式调用委托handler1?.Invoke();//输出:调用handler1 从对于第一种委托的声明与使用，我们可以发现似乎委托就是函数指针，调用该委托等价于调用该函数方法。在单播的情况下确实是这样，考虑下面这种情况： 1234567891011121314151617181920212223//声明委托public Action handler1;//无参数，void返回类型的函数声明public void ConsoleString()&#123; Console.Writeline(&quot;调用handler1&quot;);&#125;public void ConsoleNumber()&#123; Console.WriteLine(114514);&#125;//将方法添加到委托中。handler1 += ConsoleString;handler1 += ConsoleNumber;//显式调用委托handler1?.Invoke();//输出:调用handler1114514 这就是委托的多播，我们可以发现委托会调用所有已添加的方法，据此我们也可以推测委托类的实际实现，它可能包含如下几个部分： 对目标方法的引用； 如果目标方法是实例方法，那它应该还需要持有包含目标方法的对象的引用； 支持多播委托的链表容器；为什么选择链表呢，首先是为了支持动态大小，并且链表的删除是O(1),我们如果需要频繁添加和移除方法链表的效率肯定最高，最后是链表的结构很灵活，链表节点可以存储任意类型的方法引用，并且链式调用可以通过修改指针来改变调用顺序。 事实上在远古时期的.Net Framework中，委托的实现是基于函数指针的，但是函数指针的缺点很明显，不支持多播委托，并且安全性较弱，从.Net Framework2.0之后，委托的实现就变成了一个委托类，在编译时自动生成，而委托类的实现.Net并没有公开，但是实际核心实现跟我们推测的，应该是大差不差的。 对于上面的代码，我们还可以使用lambda表达式来简化这两个函数的声明： 12345678910111213//声明委托public Action handler1;//利用lambda表达式将方法添加到委托中。handler1 += () =&gt; &#123; Console.WriteLine(&quot;调用MyDelegate1&quot;); &#125;;handler1 += () =&gt; &#123; Console.WriteLine(114514); &#125;;//显式调用委托handler1?.Invoke();//输出:调用handler1114514 再来看一下有返回值类型的Func委托,对于我们定义的第三种委托进行使用，同样采取lambda表达式简化函数声明过程： 1234567891011121314151617181920212223242526272829 public Func&lt;int, string, int&gt; handler3; public static x = 0; handler3 += (param1, param2) =&gt; &#123; int sum = param1 + x++; Console.WriteLine(param2 + &quot;:&quot; + sum); return sum; &#125;; //在只添加一个函数的情况下调用 handler3?.Invoke(0, &quot;填入的数字加上x后是&quot;); handler3 += (param1, param2) =&gt; &#123; int sum = param1 + x++; Console.WriteLine(param2 + &quot;:&quot; + sum); return sum; &#125;; //在添加了两个一模一样的函数的情况下调用 var t = handler3?.Invoke(0, &quot;填入的数字加上x后是&quot;); //输出返回值 Console.WriteLine(&quot;最终返回值是：&quot;+t);//全部输出:填入的数字加上x后是:0填入的数字加上x后是:1填入的数字加上x后是:2最终返回值是：2 对于这个Func委托，我们添加了两个一模一样的方法，即对于同一个方法添加两次。我们发现在添加了这个方法两次的时候，我们执行委托将会执行两遍这个函数，然而委托的返回值并不是一个函数返回值列表int[]，而仅仅是一个int，从这里我们可以知道，对于一个有返回值的委托，它的最终返回值将会是最后一次调用的方法的返回值。最后我们来讲一下委托的缺点： 委托的缺点： 委托会造成内存泄漏：委托会引用一个方法，如果这个方法是一个实例方法（非静态方法）的话，那么这个方法必须隶属于一个对象，拿一个委托引用这个方法，那么这个对象必须存在在内存中，即便没有其他引用变量引用这个对象了，这个对象的内存也不能被释放，因为一旦释放，内存就不能再间接调用对象的方法了。 多播委托同样在维护上存在一定的困难性，容易导致所有的方法重置。我们在上面所有的例子中给委托添加方法都是使用的+=，但是委托可以使用=赋值，一旦使用了等号赋值，委托之前添加的所有函数将会被清空，也就是会从多播变成单播，并且不会有任何的报错，而如果大项目中出现了这样的小错误，排查起来也是需要费点功夫的。 嵌套调用可读性差 讲到这里，C#中的委托差不多就讲完了，那什么又是C#中的事件呢，委托看起来已经很已经很方便了，为什么还要事件呢？ C#中的Event事件的本质就是委托字段的包装器，声明的关键词为event。对于显式声明的委托，事件的声明方式如下： 12345678910111213//定义一个不含参数列表，没有返回值的委托public delegate void MyDelegate1();//声明该委托的字段public MyDelegate1 handler;//声明该委托类型的事件public event MyDelegate1 actionEvent;//定义一个含有两个参数，返回值为int类型的委托pulic delegate int MyDelegate2(int param1,param2);//声明该委托的字段public MyDelegate2 handler;//声明改委托类型的事件public event MyDelegate2 funcEvent; 同样可以使用Action与Func来简化声明： 12345//声明一个不含参数列表，没有返回值的事件public event Action actionEvent;//声明一个含两个参数，返回值为int类型的事件public event Func&lt;int,int,int&gt; funcEvent; 事实上，我们仅仅是多加了一个event关键词来声明该委托的事件类型，事件的出现就是为了解决多播委托的维护问题，事件只允许通过+=或者-=来访问进行方法的添加与删除，而不允许通过=赋值，实际上事件完整的声明方式类似属性，有add与remove两个事件处理器，并且事件更加安全，不允许外部去触发事件，事件还可以使用！=这个语法糖来进行判空。C#中的事件就是对委托实例的阉割，让它更安全。 这些大概就是C#中委托与事件的大部分内容，在实际开发中，他们有着非常广泛的使用场景，比如回调函数的实现，消息的传递，观察者模式的实现，异步方法与面向事件的设计模式……利用好事件系统可以为项目提供很大的灵活性，是开发中不可或缺的一部分。 C++中的事件机制我们在上面反复提到一个词：函数指针，它是在C++中实现委托与事件机制的关键。C++并没有像C#那样内置的委托类型来处理事件，而需要自己去管理函数指针，并且利用回调函数的方式来实现。考虑最简单的实现： 1234567891011121314151617// 定义函数指针类型：传入一个int参数,无返回值的函数指针typedef void (*EventHandler)(int);//声明一个函数指针对象eventHandlerprivate EventHandler eventHandler;// 定义格式匹配的事件处理函数void MyEventHandler(int arg)&#123; std::cout &lt;&lt; &quot;Event Handler: &quot; &lt;&lt; arg &lt;&lt; std::endl;&#125;//为函数指针赋值eventHandler = MyEventHandler;//执行事件eventHandler(10);//输出Event Handler:10 直接使用函数指针有不少的缺点： 无法捕获上下文信息，函数指针只能指向静态函数或者全局函数； 不支持多态，即函数指针只能指向固定的函数签名； 语法相对繁琐，可读性差； 安全性差，函数指针没有类型检查与空指针检查。 在C11之后，标准库提供了一个通用的函数封装类：std::function&lt;返回值类型(参数类型1，参数类型2，...)&gt; 变量名，它可以说是升级版函数指针，可以用于存储、传递和调用各种类型的可调用(函数)对象（例如函数指针、成员函数指针、lambda 表达式等），所以上面的代码可以改成如下形式： 123456789101112131415//声明function对象std::function&lt;void(int)&gt; eventHandler;// 定义格式匹配的事件处理函数void MyEventHandler(int arg)&#123; std::cout &lt;&lt; &quot;Event Handler: &quot; &lt;&lt; arg &lt;&lt; std::endl;&#125;//赋值eventHandler = MyEventHandler;//执行事件eventHandler(10);//输出Event Handler:10 它几乎解决了所有函数指针的缺点： 支持捕获上下文，可以捕获局部变量与this指针，可以实现闭包； 支持多态，可以保存普通函数，函数指针，lambda表达式，成员函数等各种函数对象； 声明格式清晰，可读性好； 严格的类型检查； std::function的底层实现的关键是多态技术与类型擦除，通过使用模板和虚函数来实现对不同类型的函数对象进行类型擦除和统一的调用接口。简单的一个function类型同样不支持多播，我们需要手动实现一下事件多播，考虑最简单的实现方式，我们利用一个vector容器存储function对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#头文件// 事件处理器的类型定义using EventHandler = std::function&lt;void()&gt;;class Event&#123;public: // 添加事件处理器 void AddHandler(const EventHandler&amp; handler) &#123; handlers.emplace_back(handler); &#125; // 移除事件处理函数 void RemoveHandler(const EventHandler&amp; handler) &#123; for (auto it = handlers_.begin(); it != handlers_.end(); ++it) &#123; if (*it == handler) &#123; handlers_.erase(it); break; &#125; &#125; &#125; // 触发事件 void Invoke() &#123; for (const auto&amp; handler : handlers) &#123; handler(); &#125; &#125;private: std::vector&lt;EventHandler&gt; handlers; void OnEvent1() &#123; cout &lt;&lt; &quot;Event 1 handled&quot; &lt;&lt; endl; &#125; void OnEvent2() &#123; cout &lt;&lt; &quot;Event 2 handled&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Event event; // 添加事件处理器 event.AddHandler(OnEvent1); event.AddHandler(OnEvent2); // 触发事件 event.Invoke(); return 0;&#125;//输出Event 1 handledEvent 2 handled 在这里我们手动实现了一个Event类，并且支持了函数事件的添加与移除以及触发。当然这是最简单也最粗糙的实现，我们可以发现在对事件的移除上的时间复杂度是O(n),在涉及频繁添加和移除事件处理函数的场景中性能是比较差的，而常见的容器里面，map跟list的删除性能是比较好的，参考C#的委托类的实现思路，我们可以使用list作为容器来对上面代码进行修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;list&gt;using namespace std;// 事件处理函数类型using EventHandler = function&lt;void()&gt;;class Event&#123;public: // 添加事件处理函数 void AddHandler(const EventHandler&amp; handler) &#123; handlers_.push_back(handler); &#125; // 移除事件处理函数 void RemoveHandler(const EventHandler&amp; handler) &#123; handlers_.remove(handler); &#125; // 触发事件 void Invoke() &#123; for (const auto&amp; handler : handlers_) &#123; handler(); &#125; &#125;private: list&lt;EventHandler&gt; handlers_;&#125;;int main()&#123; Event event; // 添加匿名事件处理函数 event.AddHandler([]() &#123; cout &lt;&lt; &quot;Event 1 handled&quot; &lt;&lt; endl; &#125;); event.AddHandler([]() &#123; cout &lt;&lt; &quot;Event 2 handled&quot; &lt;&lt; endl; &#125;); // 触发事件 event.Invoke(); // 移除匿名事件处理函数 event.RemoveHandler([]() &#123; cout &lt;&lt; &quot;Event 1 handled&quot; &lt;&lt; endl; &#125;); // 再次触发事件 event.Invoke(); return 0;&#125;//第一次输出Event 1 handledEvent 2 handled //第二次输出Event 2 handled 这样就算是实现了一个不错的事件对象，支持多播并且性能可观，我们可以利用它来实现C++中的消息机制。当然这里就不过多描述了，感兴趣的朋友可以自己动手试一试 。我们还能使用std::bind来进行参数绑定： 12345678910111213141516171819int main()&#123; Event event; int localVar = 114514; // 局部变量 // 使用 bind 将匿名函数与局部变量进行绑定 event.AddHandler(bind([](int value) &#123; cout &lt;&lt; &quot;Event handled with local variable: &quot; &lt;&lt; value &lt;&lt; endl; &#125;, localVar)); // 触发事件 event.Invoke(); return 0;&#125;//输出Event handled with local variable:114514 利用std::function与std::bind可以实现灵活可复用的函数对象与回调，在大部分回调函数的实现场景中我们都应该选择这样的实现。我们也可以发现，上面的多播是针对单一函数对象的多播，即返回值与参数列表都匹配。事实上，我们还可以利用模板去实现对任意参数的函数对象的多播，更甚者，还可以利用模板与元组std::tuple，实现多返回值，多参数的事件多播。虽然我们的实现非常自由，但是这样处理对代码的可读性与维护都会造成比较大的困难，在实际开发中还是需要按量实现。 相信到了这里，对于C#与C++中事件机制的处理的差异，已经非常明显了： C#中，内置了delegate与event类型，存在多播机制，使用非常方便，而在C++中，我们需要手动管理内存，并且需要利用容器对std::function进行封装，才能实现类似C#的委托多播效果，当然它更加灵活，在性能上也是更加可控的。 写在最后：对Lambda表达式的讨论Lambda表达式作为在C#与C++中都很常用的匿名函数实现方式，在上文中也是反复提到，我们有必要对它的实现与性能做一定的了解。 在C#中，Lambda 表达式的实现是通过编译器将 Lambda 表达式转换为委托类型或表达式树，并在运行时执行。在编译时，编译器会生成一个匿名方法，并将 Lambda 表达式转换为一个委托类型的实例，其中包含了对外部变量的引用。在运行时，Lambda 表达式可以像其他委托一样被调用，并在执行时访问捕获的外部变量的值，形成了闭包。考虑下面这种实现： 123456789101112131415public class TestClass&#123; private int instanceInt; public void Test() &#123; for (int i = 0; i &lt; 100; i++) &#123; Action act = () =&gt; &#123; int x = instanceInt; &#125;; &#125; &#125;&#125; 在匿名方法中声明一个int变量x，去捕获实例字段instanceInt，并尝试在循环中对一个委托对象赋值，这样的写法会导致发生100次的内存分配。如果 lambda 表达式使用了实例方法或实例属性，而不是静态方法或静态属性，那么在每次执行 lambda 表达式时，都会为 lambda 表达式分配一块内存来存储实例方法或实例属性的引用。这样的做法将会引起性能问题。 如果捕获局部变量，比如这样： 12345678910111213public class TestClass&#123; public void Test() &#123; for (int i = 0; i &lt; 100; i++) &#123; int localInt = 0; Action act = () =&gt; &#123; int x = localInt; &#125;; &#125; &#125;&#125; 它甚至会导致200次的内存分配，编译器会为每一次捕获的局部变量创建匿名类对象来保存该局部变量，然后使用匿名方法去创建Action对象并赋值给act。 而我们可以通过增加参数数量去传递要捕获的参数来避免对外部变量的访问从而优化掉这些多余的内存分配。对于上面的代码，修改如下： 123456789101112131415public class TestClass&#123; public void Test() &#123; for (int i = 0; i &lt; 100; i++) &#123; int localInt = 0; CallAction(localInt,(param) =&gt; &#123; int x = param; &#125;); &#125; &#125;&#125; 这样，整个过程就只会导致1次内存分配。 在C++中，Lambda表达式的使用同样有着需要注意的问题。 12345678910111213141516171819std::vector&lt;int&gt; myVector = &#123;1, 2, 3, 4, 5&#125;;// 使用引用捕获的 lambda 表达式auto lambdaWithRefCapture = [&amp;myVector]() &#123; std::cout &lt;&lt; &quot;Lambda with reference capture: &quot;; for (const auto&amp; val : myVector) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;;// 不使用引用捕获的 lambda 表达式auto lambdaWithoutRefCapture = [myVector]() &#123; std::cout &lt;&lt; &quot;Lambda without reference capture: &quot;; for (const auto&amp; val : myVector) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;; 虽然最终的输出一致，但是两者的性能存在差异，使用引用捕获，直接访问了外部的 myVector，没有进行复制或移动操作，而 lambdaWithoutRefCapture 没有使用引用捕获，会进行了一次 vector 对象的复制操作，从而产生了额外的内存开销。 同时在C++中，使用Lambda表达式更应该小心捕获对象的生命周期，避免访问已销毁对象，而对于指针对象，我们都应该使用智能指针进行管理，让我们更少地遇到内存泄漏这样的问题。 参考：知乎-芯片烤电池：C++回调函数及std::function与std::bind 自然有猫仙人：C#委托与匿名方法内存分配总结 有道云笔记：委托的底层机制实现 知乎-Ruyi Y：C#委托与事件","categories":[{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/categories/C/"},{"name":"C#","slug":"C/C","permalink":"https://wyryyds.github.io/categories/C/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"}]},{"title":"2023春招总结","slug":"2023春招总结","date":"2023-03-29T07:30:27.797Z","updated":"2023-06-15T13:11:30.725Z","comments":true,"path":"2023/03/29/2023春招总结/","link":"","permalink":"https://wyryyds.github.io/2023/03/29/2023%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"行业的寒气是否退散尚不得知，但就2023年春招的形势来看，面向24届的实习岗还是不在少数，几乎各家都有在积极筹备暑期实习与一些零散的日常实习招聘，总的而言身边很多24届的朋友都有不错的进展。尽管博主还是25届，但是抱着试一试的心态，还是投递了几家公司的春招，幸运的是，也是在最后拿到一些offer，也更加明确了以后需要提升的方向。 首先说一下投递情况：腾讯：投递后无消息（简历挂，推测是去年的面评很差） 吉比特：简历挂。 米哈游：简历挂。 字节朝夕光年：简历挂。 剑心互娱：笔试挂。 心动游戏：拒绝笔试。 疯狂游戏：拒绝笔试。 育碧成都：笔试+一轮技术面，一周后hr通知需求变化无hc挂。 西山居：笔试+一轮技术面，一面挂。 网易互娱：HR面+一轮技术面，无后续默认挂。 网易雷火：笔试+一轮技术面，一面挂。 ————–5.9更新———– 西山居：seed免面试通过 英雄游戏：流程中 电魂游戏：5.5投递，当天hr电话联系约面，5.6日面试，半小时后hr通知通过… 跌跌撞撞也算是春招有成果了（开森） 这样一看感觉好像挺挂彩的，也确实挺打击的，总觉得自己的工程能力似乎还不错，但其实真正去招聘才知道自己的竞争力有多差。尽管投递的公司没有几家，但那段时间整个人都非常折磨：等通知，做笔试，补八股，面试后抱着期待的心情等结果。也确实挺丢人的，刚面完的那个晚上会有点睡不着觉，总是感觉似乎答得还不错，会不会第二天就OC，结果却往往让人失望。到后面也算是慢慢有了磨练的感觉，无论面试反问面试官给你什么样的反馈，都应该明白横向是不可缺少的环节，所以也不必抱有太大的期待。 由于笔试的内容我没有特意去记录，所以笔试题就不分享了，主要是把各家的面试内容进行记录与总结，也希望这一部分能对看到的人起到帮助。项目部分的内容还是见仁见智，根据每个人的项目经历与实习经历应该做出区分。 面试内容与答案育碧成都1.聊一下实习期间具体用行为树做了什么。主要是用行为树去设计几类怪物AI，用自拓展节点去组织具体的行为模块，并且参考htn的形式对行为模块做了分层处理，同时做了数据分离。 2.对于行为树中的各个模块是如何组织设计的。将行为分类，划分通用子树，设置明确的行为条件与特殊状况的事件处理机制…. 推荐参考：AI的被动式处理 3.AI感知器，寻路以及战斗部分的具体实现。推荐参考： AI分享站 烟雨：基于行为树的技能系统 GDC最后生还者中的近战AI设计 4.表现资产的配置问题。动画的处理方式；战斗表现是用timeline的形式去处理，还是用其他方式去生成。 推荐参考： 行为树的常用动画配置方式 动画与控制系统的讨论 5.数据分离做了哪些工作，共享行为树的设计与使用场景用一个共享单例管理某种类型行为树的通用数据，数据由SO配置，供多个AI实体访问，实体做到逻辑与表现分离，每个实体的行为树只需要执行逻辑部分。这种设计在后端同样适用。在场景中有较多同类型怪物的情况下使用，可以节省开销。 推荐参考：黑板与共享数据 6.行为树的GC问题行为树的数据类型设计，比如shared类型数据是否会拆箱装箱，利用泛型的设计可以避免拆箱装箱。 行为树的加载需要反序列化，可能会引发GC问题。 推荐参考： Behavior Designer官网讨论的行为树加载问题 行为树加载的反序列化性能问题 7.讲一下项目中对象池的工作流程，做了哪些接口，如何设计。工作流程：池初始化-&gt;拿取对象-&gt;容量检查-&gt;回收机制-&gt;回收….. 一个通用性强的对象池除了需要有基础的拿取回收接口外，最好定义一些生命周期函数的委托方法供外部注册，比如OnGetBefore()，OnReleaseBefore()等等，也要有良好的扩容收缩机制，类比stl中的vector，很值得一提的是不同数据容器的选取会对池的各种操作产生影响，同时也会影响到池中对象的活跃度，类比栈对象池与队列对象池，队列对象池的对象平均活跃程度是更高的（栈底的对象可能永远不会被拿取）。 推荐参考：基于队列的对象池 8.项目中的全局消息机制如何实现，消息从广播分发到相应执行的过程，中断与注销机制。利用枚举加字典可以很快的设计好需要的数据结构。提供给外部需要的注册与注销方法，响应时遍历指定消息类型的整个订阅列表进行invoke。参考的话等我以后补一篇相应内容的帖子好了（鸽）。 9.项目中UI的搭建，注意过相关开销没有。对于UI的搭建，不同项目处理的方式不同，不做赘述，只是需要简单注意一下基本原则与优化即可。 推荐参考： MVI响应式架构UI 《Unity3D高级编程：主编手记》：UI优化 10.Unity中资源的动态加载与本地保存。我在项目中用得比较多的加载方式还是Resource，本地保存的是用的PlayerPrefs。 推荐参考：Resource与AB包的区别讨论 11.2D游戏中的AI如何设计，做了哪些模块。寻路上直接用的Pathfinding插件，其余的部分用的状态模式处理的AI行为。 12.C#中用List做对象池怎么处理拿取与回收，用链表怎么实现对象池。碰巧的是我确实也用List做过对象池，实际上选什么类型的数据容器都是大差不差，而对于List的对象池的拿取其实是想问你优化。最直接的优化策略就是双指针，一个指针记录上一次拿取的index，需要拿取的时候往后拿，同时每次做取余操作防止溢出。另一个指针在回收时指向最后被回收的index，判断池满的条件就是前者追上后者。而链表实现对象池在内存池中的应用非常常见， 推荐参考：STL空间配置器解析 总结：育碧的面试确实很出人意料，没有问很多的八股，更多的是考察你对项目的理解以及你的开发能力，包括对相关部分的深度。是三个面试官一起问，所以压力很大，但是总的而言整个面试很务实，体验也是非常不错，遗憾的是没有oc，hr后续通知需求变化，应该就是横向比较所以筛掉了，毕竟25届加双非本，确实不具备很强的竞争性。 西山居：剑侠世界三项目组1.C++与C的区别虽然这个问题可以扯非常多的东西，但是并不建议在面试官面前卖弄见解打开你的话匣子。最简单直接的就是说明C++在oop上的优越性以及C++的新特性，C++几乎是C的超集。 2.面向对象的三大特性，什么是多态基础中的基础但是重点中的重点。 3.对象的内存模型头部虚指针，按照类的继承顺序与声明顺序布局。 4.虚函数的实现方式，虚表的建立时间虚函数的实现通过虚表与虚表指针，虚表在编译时就已经确定。 5.深拷贝与浅拷贝浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存；深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。 6.父类构造函数能不能调用虚函数可以，但是会屏蔽多态机制。因为在父类的构造函数中子类特有的成分尚未初始化。 7.值传递与引用传递传引用直接访问对象，不会产生拷贝，传值的拷贝可能造成很大开销，比如传递vector类型变量。 8.拷贝构造函数的常见形式构造函数加引用参数 9.delete与delete[]new申请的内存，释放时用delete；使用new [ ]申请的内存释放时要用delete [ ]，否则可能产生内存泄漏 10.vector与list有什么区别，各自的使用场景两种的区别还挺大的，但是面试一直很喜欢问这个问题。 list是由双向链表实现的，内存空间是不连续的。由链表的实现原理可知： 优点：插入和删除效率较高。只需要在插入的地方更改指针的指向即可，不用移动数据。 缺点：List查询效率较低，时间复杂度为O（n） vector拥有一段连续的内存空间，并且起始地址不变,与数组类似： 优点：便于随机访问，时间复杂度为O（1）， 缺点：因为内存空间是连续的，所以在进入插入和删除操作时，会造成内存块的拷贝，时间复杂度为O（n）。 使用场景跟据需求操作的时间复杂度去确定。 11.红黑树与平衡二叉树的区别不描述直接上链接了。推荐参考：知乎帅地：红黑树与平衡二叉树区别 12.树上的查找时间复杂度分析推荐参考：二叉树，二叉搜索树，平衡二叉树与红黑树的时间复杂分析 13.哈希表的实现方式常见的有桶数组加链表 14.哈希冲突解决方法，列举3个上拉链法，开放寻址法，再哈希法….. 15.push_back跟emplace_back的具体区别emplace_back() 函数在原理上比 push_back() 有了一定的改进，包括在内存优化方面和运行效率方面。内存优化主要体现在使用了就地构造（直接在容器内构造对象，不用拷贝一个复制品再使用）+强制类型转换的方法来实现，在运行效率方面，由于省去了拷贝构造过程，因此也有一定的提升。 16.aoi算法MMORPG游戏中最常见的优化算法之一，推荐参考： 知乎：AOI算法 17.navmesh的原理主要是三角形寻路网格的构建与基于该网格的A*寻路方法。 推荐参考： Github：recastnavigation 陆泽西：架构设计NavMesh寻路 18.A*算法的具体实现与优化非常经典的高频次问题。 推荐参考： 阿里云：A*算法详解 A*算法的几种优化 19.行为树模块的的设计与实现20.讲一下全局消息机制的实现重复的问题就不再复述了，C++的八股推荐参考：知乎Steven王：游戏开发面经汇总 总结：不是很走运，面试官在一开始就跟我坦言他是服务器开发方向，而我是客户端。整个面试过程非常的轻松愉悦，并且值得开心的是面试官也给了我一个不错的评价，虽然没有后续，但确实是一次非常好的面试体验。 网易互娱：在线游戏事业部1.讲一下行为树模块的实现2.讲一下你的全局消息系统的实现3.讲一下你在项目中如何设计UI模块的从需求出发，根据功能设计层级面板，分离数据的处理与表现，管理器提供泛型接口。 4.UI的多界面打开后返回上一级实现听到返回上一级直接栈，非常经典的问题。 5.实现一个面板管理器的Open方法主要是考虑相似面板实现相同的接口以及利用继承管理子元素。然后open()方法中接受接口类型或者基类。 6.委托的本质是什么委托是一个类，有invoke方法…. 总结：感觉得到面试官并不是很赞成我大二过去实习。问得也比较简单，可能也是因为不会lua的原因，与项目需求并不是特别匹配。 网易雷火：逆水寒项目组（补档）1.项目中的UI如何搭建的2.对象池的实现3.项目中的问题与瓶颈在跟面试官说做过肉鸽类游戏后面试官一针见血的指出了项目中是不是存在性能问题，确实是在场景中子弹与怪物过多的情况下会遇到帧率降低游戏卡顿的情况，面试官也试着问了一下有没有做优化处理，回答的是通过游戏设计层面去限制了子弹射速并且加速了回收策略，但是情况确实还是会出现。也被面试官吐槽了一句做得太粗糙了。 4.帧率低是因为场景中物体过多还是因为生成与销毁太密集当时完全没有去做相关的测试，所以没有答上来。也确实在遇到这种情况需要去用profile做性能检测。 5.四叉树优化场景中物体的碰撞检测还是基于上面卡顿的情景，提到可以用二叉树或者四叉树做碰撞检测优化。 推荐参考：KillerAery：空间数据结构 6.做过多少种UI，用过什么框架做过背包，滑动列表，功能性界面等等还有基础UI，框架的话说用过MVC跟MVI，还有消息机制的UI，但是面试官并没有再细问。 7.对背包系统做优化（同一面板有大量UI元素如何避免加载卡顿）提问场景是背包中有大量元素，如果打开时发现加载卡顿如何优化。当时的回答主要是从预加载，缓存队列跟对象池进行的分析，感觉面试官还比较满意。 预加载：在很有可能打开背包的情况的下提前进行部分元素的预加载，比如战斗结束领取完奖励这种情景，很有可能会打开背包查看物品，进行预加载，设置一个时间戳假如到时间没有打开背包再销毁…. 利用缓存队列分批放在多帧内加载，按照批次对物品进行加载避免某一帧大量元素的加载。 对象池：牺牲内存保留部分背包内UI元素，打开背包时只需进行初始化。 8.如何降低draw call当时被问到一瞬间很懵，然后明白可能面试官可能希望对背包系统的优化是从引擎层面来讲。就答了网格合并跟批处理，然后就掉进了陷阱。 9.动静态图集基于第七题与第八题的情景，面试官问背包内有大量UI图标如何减少draw call，还问我日常开发有没有关注过，我诚实地说了没有。回答说把图标全部划分到同一个图集里，优化批处理降低draw call。面试官就继续说如果图标元素有很多张图集，然后这些图标都来自不同的图集，那draw call并没有得到优化，这种情况怎么办。我当时就懵懵的了，答了个分类处理图标并把背包按类别查看可以提高命中率，他问还有什么更好的方法吗，当时脑子一抽没想到动态图集，然后面试官就笑着说你做过图集没有，我说没有，他说还可以运行时动态生成图集。我才恍然大悟，直接在运行时把当前页面的图标动态合并到一张图集上就行。 10.全局消息机制的实现11.行为树模块的实现12.技能系统与角色属性管理问了怎么实现的技能系统，回答每个技能都是一个单独类，然后带有各自的属性与一些依赖条件，与角色的属性绑定，计算单独放在属性管理器里面。 13.数据配置与工具开发用得最多的还是SO，策划直接在引擎里面配置数据，因为没有后端采取的是最方便的方法。然后面试官问有没有为行为树或者其他系统做过数据配置的工具跟一些可视化工具。巧合的是因为之前开发的时候都有考虑过，回答说都做了数据分离方便策划改数据，可视化在战斗上做了，也算是半个工具吧。 14.介绍Unity的动画系统介绍完还问我对Unity的动画系统哪些最熟悉，做过哪些动画到了什么地步。这问题太宽泛了就不贴答案了，感兴趣可以问gpt。 15.Avatar Mask的使用经典上下半身分离的动画功能。这一点的话官方文档就有很好的说明：Unity：AvatarMask 16.动画混合树与分层动画推荐参考：Unity动画系统详解 17.骨骼动画原理当时回答了一堆概念，然后面试官说方式是这么个方式，怎么实现了解过吗，答没有。 推荐参考：骨骼动画的实现 18.骨骼如何带动蒙皮也是答了一堆概念然后问我蒙皮算法实现，也不会。 推荐参考：线性蒙皮分解算法 19.会不会python会但不多，不想挖坑直接说了不会。 20.有没有写过ECS跟jobsystem了解但没有写过。推荐参考：烟雨：Unity DOTS 21.讲讲UnityShader说了一些工作流与UnityShader的设计，但是实际开发项目中没有用过，只跟书实现过效果，被面试官批评了简历应该写了解而不是熟悉。 22.对简历的一些建议23.讲讲对引擎基础架构的认识聊了一些104学到的东西，已经被问麻了当时不知道该怎么回答了。 24.对开发哪些模块最感兴趣25.讲一下C++1126.右值引用与左值引用当时脑子一团浆糊，说了一点简单的然后其余的记不清了。 推荐参考：详解左值引用与右值引用 27.智能指针的使用场景确实c++开发的经验很少，面试官问我那几种智能指针的使用场景，答得支支吾吾的，基本上只会说智能管理内存，更安全更方便。还问我shared_ptr跟单例的分别作用场景，为什么在这要用shared_ptr不选择用单例，也没有答好。后面还断网了。 28.对mmo游戏的讨论29.对游戏中UI开发的讨论聊得很开心但是经常断网….. 总结：被狠狠拷打了，面试官一上来就说自己是引擎负责人，然后说会问一些偏引擎跟优化的东西，被问了很多细节跟实操，确实对很多知识还停留在了解层面。本来感觉反问环节是很好拉近距离的时候，结果聊得挺开心的但是经常断网，真的难绷，还不知道是哪边的问题。但是面试官确实给出了非常多的学习方向与内容，问的问题很拓展我的思考，非常有用的一次面试。 电魂游戏：野蛮人2项目组1.对大学一些经历的询问2.介绍项目并且简单介绍技术点3.事件系统的流程4.之前做游戏的一些经历5.行为树的内部运行方式6.二叉树的遍历7.以往的经历中对自己提升最大的事情8.对过去参加过的游戏开发类活动的总结9.构造函数与析构函数10.虚析构函数的作用11.new与malloc12.申请内存会调用哪些底层接口13.是否了解Windows编程14.红黑树的特征15.红黑树的构造过程16.对常见算法的理解，比如贪心与搜索17.挑一个最熟悉的算法讲一下实现与应用场景18.口述BFS并且打印路径19.C#值类型与引用类型20.C#内存管理机制21.GC与CLR22.编译原理23.tcp与udp的区别24.udp如何实现稳定传输25.说一下UnityShader26.后处理的实现与原理27.口述边缘检测的大致shader28.渲染状态的设置29.深度检测与透明度测试30.项目中行为树的详细实现31.对未来的工作规划反问：1.实习负责哪些内容2.项目使用的大致架构总结：面试的内容非常宽泛，但是并不是非常深入，能感觉到项目组会希望你的潜力大一点比较好，面试官也说会希望实习生会的方向多一点，项目中负责的内容主要是看能力。面试官也很温柔，就是因为腾讯会议出了问题所以声音有点小。后面有接近10分钟面试官对我的主动输出，说了项目架构，项目人员情况与团队氛围，最后结束语是hr会联系你的，当时感觉应该是稳了，半小时后hr口头告知通过下周发正式录用，好耶好耶~ 写在最后整个春招的内容大概就是这些了，写这篇博客也是写了半天累死了，不过希望能给大家带来帮助。越面试是会越有经验的，在你回答当前这个问题的时候，你就应该猜到面试官很有可能会从你的回答中去提出下一个问题来挖掘你的深度，所以面试的表现应该始终把握在一个量内，能完整的回答上当前问题，但是不要过于卖弄你的知识面以防被深挖太多从而丢掉原有的分数。同时对自己简历内容的把控跟项目经验也是非常重要的一部分，你知道应该要知道面试官从你的简历上会提问哪些内容，提早做好应对，会让你更加的从容。再就是基础是一切的根基，并且深深地影响着你的面试内容。像西山居的面试官感觉我太小，计网跟操作系统都还不会，所以只能往八股跟项目去问，而网易那边也是因为我不会lua，直接丢失了很核心的竞争力。所以今后的学习方向，也是要从这些踩坑踩出来的经验出发，打好一个计算机学科该有的基础，完善的cpp项目经验以及工程能力，当然还有算法。希望日后能取得不错的成果。","categories":[{"name":"求职","slug":"求职","permalink":"https://wyryyds.github.io/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"春招","slug":"春招","permalink":"https://wyryyds.github.io/tags/%E6%98%A5%E6%8B%9B/"}]}],"categories":[{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/categories/Game-Design/"},{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/categories/UE5/"},{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/categories/Unity/"},{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/categories/C/"},{"name":"C#","slug":"C/C","permalink":"https://wyryyds.github.io/categories/C/C/"},{"name":"求职","slug":"求职","permalink":"https://wyryyds.github.io/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"Destiny2","slug":"Destiny2","permalink":"https://wyryyds.github.io/tags/Destiny2/"},{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/tags/Game-Design/"},{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/tags/UE5/"},{"name":"Lyra","slug":"Lyra","permalink":"https://wyryyds.github.io/tags/Lyra/"},{"name":"C#","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/tags/Unity/"},{"name":"xlua","slug":"xlua","permalink":"https://wyryyds.github.io/tags/xlua/"},{"name":"ILRuntime","slug":"ILRuntime","permalink":"https://wyryyds.github.io/tags/ILRuntime/"},{"name":"HyBridCLR，热更新","slug":"HyBridCLR，热更新","permalink":"https://wyryyds.github.io/tags/HyBridCLR%EF%BC%8C%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"春招","slug":"春招","permalink":"https://wyryyds.github.io/tags/%E6%98%A5%E6%8B%9B/"}]}