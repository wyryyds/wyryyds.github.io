{"meta":{"title":"武田晴海","subtitle":"","description":"","author":"武田晴海","url":"https://wyryyds.github.io","root":"/"},"pages":[{"title":"关于博主","date":"2023-09-11T14:36:11.288Z","updated":"2023-09-11T14:36:11.288Z","comments":true,"path":"about.html","permalink":"https://wyryyds.github.io/about.html","excerpt":"","text":"个人介绍很高兴认识你^O^,这里是小海！ 现就读于湖南工业大学计算机学院软件工程专业。目前正在学院双创中心游戏组进行游戏开发相关知识的学习。 我对游戏客户端，游戏AI，动画模拟等内容有着浓厚的兴趣。 以往经历 电魂网络 | 野蛮人大作战2：客户端开发实习 深圳拂曦科技 | 异度行者：客户端AI开发实习 我的作品 2023 CIGA Game Jam Ludum Dare 51 2022 Booom 创作赛 与我联系QQ：2245958498 邮箱：&#99;&#111;&#x72;&#110;&#x65;&#x6c;&#x69;&#x75;&#115;&#95;&#x68;&#117;&#x74;&#64;&#111;&#117;&#116;&#x6c;&#111;&#x6f;&#107;&#x2e;&#x63;&#111;&#109;"},{"title":"文章归档","date":"2023-04-02T06:32:25.487Z","updated":"2023-04-02T06:32:25.487Z","comments":true,"path":"archive.html","permalink":"https://wyryyds.github.io/archive.html","excerpt":"","text":""},{"title":"书籍阅读","date":"2023-04-12T14:26:41.481Z","updated":"2023-04-12T14:26:41.481Z","comments":true,"path":"donate.html","permalink":"https://wyryyds.github.io/donate.html","excerpt":"","text":"黄昏住雨 有夜来香 云雾懒惰 伏罩此江 五感通畅 而思想滞涩 ——《哑牛》 保持思考，不被同化，在我看来就是阅读的意义。 下面是我在大学之后看过的一些个人觉得还不错的书籍，有技术方向的也有杂书，会一直保持更新。 技术学习 一些好看的书"},{"title":"我的朋友","date":"2023-05-17T15:56:23.160Z","updated":"2023-05-17T15:56:23.159Z","comments":true,"path":"PY.html","permalink":"https://wyryyds.github.io/PY.html","excerpt":"","text":"一个人的生命 我认为一半是活在朋友中的 ——老舍《可爱的成都》"}],"posts":[{"title":"","slug":"PBR","date":"2023-10-20T04:11:18.702Z","updated":"2023-10-20T04:40:52.005Z","comments":true,"path":"2023/10/20/PBR/","link":"","permalink":"https://wyryyds.github.io/2023/10/20/PBR/","excerpt":"","text":"基于能量守恒的渲染方程渲染方程的物理基础是能量守恒定律。在一个特定的位置和方向，出射光 Lo 是自发光 Le 与反射光线之和，反射光线本身是各个方向的入射光 Li 之和乘以表面反射率及入射角。 这个方程经过交叉点将出射光线与入射光线联系在一起，它代表了场景中全部的光线传输。所有更加完善的算法都可以看作是这个方程的特殊形式的解。某一点P的渲染方程可以表示为：$$L_{o}&#x3D;L_{e}+\\int_{\\Omega^{}} f_{r} \\cdot L_{i} \\cdot \\left(n \\cdot \\omega_{i}\\right) \\cdot \\mathrm{d} \\omega_{i}$$对方程中每个变量进行解释： $L_{o}$ 是P点的出射光亮度； $L_{e}$ 是P点的发出光亮度； $f_{r}$ 是P点入射方向到出射方向光的反射比例，即BxDF（BRDF，BTDF，BSDF），一般是BRDF； $\\left(n \\cdot \\omega_{i}\\right)$ 是入射角带来的入射光衰减； $\\int_{\\Omega^{}}\\cdot \\cdot \\cdot \\mathrm{d} \\omega_{i}$是入射方向半球积分。 更详细的描述是：渲染方程描述了在半球上积分后着色点 p 在半球面上接收到的 Irradiance 经过反射分布函数的转化后，在出射方向上的 Radiance。$$L_{o}\\left(p, \\omega_{o}\\right)&#x3D;L_{e}\\left(p, \\omega_{o}\\right)+\\int_{\\Omega^{+}} L_{i}\\left(p, \\omega_{i}\\right) f_{r}\\left(p, \\omega_{i}, \\omega_{o}\\right)\\left(n \\cdot \\omega_{i}\\right) \\mathrm{d} \\omega_{i}$$ 理解BRDFBRDF有两种理解方式: 第一种理解是，当给定入射角度后，BRDF可以给出所有出射方向上的反射和散射光线的相对分布情况； 第二种理解是，当给定观察方向（即出射方向）后，BRDF可以给出从所有入射方向到该出射方向的光线分布。一个更直观的理解是，当一束光线沿着入射方向I到达表面某点时，f(I, v)表示了有多少部分的能量被反射到了观察方向v上。 漫反射项 Diffuse BRDF漫反射项采用 Lambertian 光照模型计算，在该模型中假设入射光时均匀分布整个半球体，对于所有的观看角度，表面将具有相同的亮度。其中余弦在半球作用域内的积分结果为 $\\pi$ 。 $$f_{Lambert}(I,V)&#x3D;\\frac{C_{diff}}{\\pi}$$其中 $C_{diff}$ 表示漫反射光线所占的比例，也被称为漫反射颜色（Diffuse Color）。 Lambertian模型是很简单的，大部分情况下我们并不会使用这一模型，往往会选择更加复杂的漫反射项去模拟次表面散射的结果。比如Disney使用的BRDF[2]: $$f_{Lambert}(I,V)&#x3D;\\frac{BaseColor}{\\pi}(1 + (F_{D90-1})(1-n \\cdot I)^5(1+(F_{D90})(1-n \\cdot v)^5)$$$$F_{D90} &#x3D; 0.5+2 * RoughNess(h \\cdot I) ^ 2$$对于上面表达式，$BaseColor$ 表示的是表面颜色，通常通过纹理采样得到。$RoughNess$ 是表面粗糙度。这样的漫反射既考虑了在掠射角漫反射项的能量变化，也考虑了物体表面粗糙度对漫反射度的影响。 镜面反射项 Specular BRDF游戏界最常见的镜面反射模型是Microfacet Cook-Torrance BRDF，它基于微表面理论。 微表面理论的关键是：假设微观几何尺度明显大于可见波长，可将每个表面点视为光学平坦。光学平坦表面将光线分为两个方向：反射和折射方向。 每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。 在计算BRDF项时，指定光方向l和视图方向v。 这意味着所有表面点，只有那些恰好正确朝向可以将l反射到v的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。 在下图中，我们可以看到这些“正确朝向”的表面点的表面法线m正好位于l和v之间的中间位置。l和v之间的矢量称为半矢量（half-vector）或半角矢量（half-angle vector）; 我们将其表示为h。 仅m &#x3D; h的表面点的朝向才会将光线l反射到视线v的方向，其他表面点对BRDF没有贡献。 并非所有m &#x3D; h的表面点都会积极地对反射做出贡献;一些被l方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失;实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。 在左侧，我们看到一些表面点从l的方向被遮挡，因此它们被遮挡并且不接收光（因此它们不能反射任何）。在中间，我们看到从视图方向v看不到一些表面点，因此当然不会看到从它们反射的任何光。在这两种情况下，这些表面点对BRDF没有贡献。实际上，虽然阴影区域没有从l接收任何直射光，但它们确实接收（并因此反射）从其他表面区域反射的光（如右图所示）。microfacet理论忽略了这些相互反射。 利用全部假设，我们可以推导出一个一般形式的Specular BRDF形式：$$f\\left(l, v\\right)&#x3D;\\frac{ D(h)F\\left(v, h\\right)G\\left(l, v, h\\right)}{4(n \\cdot l)(n \\cdot v)}$$对表达式的每个变量解释： D(h) : 法线分布函数 （Normal Distribution Function），描述微面元法线分布的概率，即正确朝向的法线的浓度。即具有正确朝向，能够将来自l的光反射到v的表面点的相对于表面面积的浓度。 F(l,h) : 菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。 G(l,v,h) : 几何函数（Geometry Function），描述微平面自成阴影的属性，即m &#x3D; h的未被遮蔽的表面点的百分比。 分母 4(n·l)(n·v）：校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。 法线分布函数主流的法线分布函数GGX（Trowbridge-Reitz）：$$D_{GGX}(m)&#x3D;\\frac{\\alpha^2}{\\pi((n \\cdot m)^2(\\alpha^2-1)+1)^2}$$在这个表达式中，$\\alpha$ 是粗糙度参数；$m$ 表示微表面的法线向量；$n$ 表示宏观表面的法线向量，两个向量都是单位向量，所以$(n \\cdot m)$表示微表面法线与宏观表面法线的相关度（对齐程度）。 菲涅尔方程主流的菲涅尔方程一般采用Schlick的Fresnel近似：$$F_{Schlick}(v,h)&#x3D;F_0+(1-F_0)(1-(v \\cdot h))^5$$表达式中 $F_0$ 是基础反射率，通常是物体正对观察视角时的反射率，对于非金属物体，这个值比较小，而金属物体比较大。常见电解质的 $F_0$ 为 0.02-0.05，导体为 0.5-1.0，对于金属材质，其 $F_0$ 是有色的，金属的颜色也来自于此。 折射率与 $F_0$ 的关系式为$$F_0&#x3D;(\\frac{n1-n2}{n1+n2})^2$$对于空气和其他介质来说，将空气的折射率视为 1，则可得到简化公式$$F_0&#x3D;(\\frac{n-1}{n+1})^2$$ 几何函数分离遮蔽阴影型的Smith几何函数最为常用，该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数来描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项： Smith-GGX Smith-Beckmann Smith-Schlick Schlick-Beckmann Schlick-GGX 这里我们举例Schlick-GGX，这也是UE4中的方案：$$G_1(w)&#x3D;\\frac{n \\cdot v}{(n \\cdot v)(1-k)+k};$$$$k &#x3D;\\frac{\\alpha}{2};$$$$\\alpha &#x3D; (\\frac{RoughNess+1}{2})^2;$$$$G(l,v,h)&#x3D;G_1(l)G1(v)$$ References Games101：光线追踪 知乎毛星云：PBR核心体系概念与总结 知乎Maple：基于物理的着色BRDF 知乎张亚坤：彻底看懂PBR &#x2F; BRDF方程 冯乐乐：Shader入门精要","categories":[],"tags":[]},{"title":"Destiny2拆解分析","slug":"Destiny2拆解分析","date":"2023-08-14T13:18:33.528Z","updated":"2023-10-22T15:18:35.907Z","comments":true,"path":"2023/08/14/Destiny2拆解分析/","link":"","permalink":"https://wyryyds.github.io/2023/08/14/Destiny2%E6%8B%86%E8%A7%A3%E5%88%86%E6%9E%90/","excerpt":"","text":"知乎文章：知乎链接 前言因为学习的需求，想试着第一次写一篇分析设计的内容，而拆解案这样的标题本身就比较大，同时也担心遭受专业策划同学们的攻击，所以我给它用自己的方式命名。没错！就叫它闲聊好了！ 本来是不准备往社交平台倒垃圾的，但是由于博客出了点小状况，而知乎文章的内嵌视频又做得还不错，所以就只好借一下知乎这个平台力（悲 言归正传，CN互联网上实际上对于命运2的学习与参考资料都比较少见，那正好项目需求，本人也是命运爱好者（常鸽朋友，所以借此机会对命运2的部分设计内容进行闲聊，也是第一次写这种内容求轻喷。 核心内容将会围绕命运2的AI系统，战斗体验，以及动画系统进行，可能会有部分偏向开发的内容。本文不会有大篇幅的具体内容拆解文案或者各种眼花缭乱的思维导图，只是希望从表现与设计的起点出发，引申讨论以拓展大家的思考。 当我们讨论命运2时，我们在讨论什么命运2有着太多的标签：FPS，MMORPG，开放世界，PVPVE…..，每一个标签都是值得拿出来拎清了讲的。而它凭借着极其优秀的射击手感与战斗体验让它从17年发行至今任然有着不少的活跃的玩家群体与社区。 作为一名资深FPS玩家，命运2的手感与打击反馈给我的感觉绝对是Top级别。同时作为游戏最大特色之一的Raid，它当中的关卡流程，解密，战斗设计，在我看来也是对大多数MMORPG游戏而言都有着非常好的借鉴意义。 当然命运2的故事背景，剧情，包括音乐与美术，也都是顶尖级别，只能说棒鸡做游戏还是有一手。感兴趣的朋友可以自己下一个体验一下，btw命运2的本体是完全免费的~ 核心系统小岛秀夫说过，聊某个游戏的部分内容而不去讨论它的核心系统是犯罪的。对于Destiny2，维基百科对它的第一句描述是：Destiny 2 is a free-to-play online first-person shooter video game developed by Bungie. 虽然各个社区里面对它到底应该是一款FPS还是RPG游戏这样的讨论每天都在上演，甚至像官方自称，命运2是一款开放世界MMORPGFPS游戏这样的头衔也是又酷又好笑，但FPS与RPG毫无疑问是它最侧重的两个内容。所以它的核心系统同样也是围绕着这两个大品类去进行延展。 而无论是宏观的去拆解设计方向也好，亦或是从细节去琢磨设计技巧，最终都是落在：你想做一款什么样的游戏，又想带给玩家什么样的体验。 我很喜欢我导师说的一句话，做策划落地很重要。那我会觉得这其实不仅仅是策划案的落地，哪怕案子中的功能，需求全部实现，而你构思设计的那份游戏体验却没有落地，也一定是违背了这份设计的初衷的，有趣好玩永远是游戏首要的。 核心一：FPS聊到FPS游戏就不得不提到的枪械设计与射击手感，这两者都是任何FPS游戏的基础。 枪械设计命运2的枪械设计是非常丰富并且系统的，当然这也与它RPG的元素息息相关。传统强竞技性的FPS游戏往往会把枪械的设计大道至简，几种类型，每个类型再在数值与手感上做一些区分的枪械，最后构成为数不多的整个游戏的武器库。 因为强竞技性的原因，这些游戏往往对枪械的熟练度有着非常高的要求，并且游戏的核心在操作与博弈，维护武器平衡是一件非常重要的事，所以往往不会追求过多的枪械去破坏游戏平衡的稳定。 而命运2充分发挥了RPG游戏的装备系统特点，它弱化了枪械的操作难度与熟练度要求，让枪械变成了一把趁手的战斗武器。 此外，它继承了传统射击游戏的枪械组合，手枪，散弹枪，机枪，狙击枪等等，并且分散出来一些小众枪械类型比如线融，斥候等等。 同时对枪械进行了品质划分，分为白蓝紫金，枪械带有不同的perk并且支持锻造，这就让枪械系统的复杂度进行了非常大的提升，并且更加考验组合。枪械的子弹也进行了区分，并且限制了弹药的获取途径，这样玩家在装备搭配与选择上就需要做出更多的思考。 射击手感至于射击手感，前面提到过命运2弱化了枪械的操作难度，即大部分枪械的上手难度与熟练程度都要比传统FPS低，这样的低门槛射击得以让他能在关卡设计中发挥出更大的优势，并且鼓励玩家在与不同类型的敌人的战斗中更换武器进行战斗以达到最佳效果，让玩家在枪械搭配上更加放开。上图中我的1，2，3号位分别就是步枪，散弹枪与机枪。 一些更细致的设计，比如弹药与枪械数值，后坐力，腰射精准度与开关镜精准度，我就不在这些相对硬核的内容上去深入讨论了。命运2实际对除了数值这一块内容外，很多操作难度上都进行了折中，他的操作是非常顺畅并且手感很明确的，当然这个折中是很有学问的，这也是那么多人称赞他的射击手感的根本原因。 命运2其实还做了一些非常独特的设计，针对不同的枪械，会有不同颜色的子弹与子弹大小，甚至对大部分枪械都有做专属的打击特效，这本身就是一件工程量很大的事情，也能看出在优化玩家体验感受上命运2也是花足了心思。 移动能力与其它命运2的移动能力是值得拿出来多讲一下的，有着滑翔与滞空能力的支持，命运2在移动能力上是打破了常规FPS游戏的一些限制的，在关卡上也借着这个能力可以设计出一些很好玩的机制，比如跳跳乐。这样的设计不仅很好的支持了命运2的大场景摆放，也与技能系统跟解密机制相搭配，丰富了游戏的操作性。 核心二：RPGRPG作为同样经典的游戏类型之一，命运2围绕它有做出非常独特的设计，为了节省时间，就围绕角色扮演，养成系统简单聊聊。 角色扮演命运2的职业系统真的是一个非常棒的设计！不仅充分发挥了异能射击的背景与优势，也将技能与属性系统完美融合进了射击战斗中。对我来说就是，我直接无敌电术士开电！！！（最没用的一个）。 一方面技能加强了清怪与玩家的战斗能力，像手雷，奶阵，近战技能，以及每个职业与属性各不相同的大招，很大的提升了战斗中的容错率，而熟悉这个游戏的朋友应该知道，命运2存在特殊的产球与产子弹机制，即通过战斗获取物资与技能的更多使用次数，这也是在许多RPG游戏中广泛存在的局内奖励机制，鼓励玩家主动出击，去获得一个良好的循环收益。因为职业的存在，也就必然存在阵容搭配，那这些就是更经典的内容了。 总而言之，职业与职业特性成为命运2中非常亮眼的FPS辅助元素，技能与射击的搭配让玩家在割草刷怪跟战斗流程上的体验都丰富了一大截。 长线养成这里不得不提到的就是命运2的光等，它是一种类似某些游戏中的战力机制，光等分为软光和硬光，软光是赛季神奇为你提供的额外光等，硬光是装备光等为你带来的光等加成。 每个副本会有推荐光等，这些内容跟传统RPG游戏是非常类似的，但是命运2的光等会影响你的输出与防御，如果你的光等低于这个本的推荐光等，那你的输出伤害跟防御能力会根据你的光等差距做出一个分阶段的带系数削弱，我们称之为压光。 这个压光是非常厉害，如果你贸然挑战比你推荐光等高出很多的副本，可能小兵的一两下普攻都会让你丢掉性命。当然好像最近的赛季做出了调整，削弱了压光的影响貌似。 而你的光等会影响副本奖励中装备的光等，并且每个赛季到达高光后，光等的提升就只能通过打巅峰球。这样的设计提高了玩家的活跃度，但也面临着内容不足的问题。 副本的数量是有限的，再怎么样换着挑战，也会遇到打本就像家常便饭并且奖励到顶的情况，而命运2在周常奖励上的设计似乎也是更希望玩家把它一部长线游玩的作品，保证周活而不是非日活这样的高活跃度不可。 装备在前面已经提到了非常多次了，它作为长线养成不可或缺的要素之一，这里还需要再对它详细说明，命运2的装备获取途主要是任务奖励与副本奖励还有兑换，而装备最重要的内容是光等与属性。 光等前面介绍过，属性这一部分本该常规的设计在命运2中也有很有意思的设计，命运2的每个属性比如韧性，纪律，敏捷上限都是100，他们并不直接作用于数值，而是通过百分比加成的方式去提升玩家的能力。 每件装备都会带有全部类型的属性点，并且支持通过锻造与模组去提升，而最有意思的一件事是，获取装备的属性是不可控，虽然机灵有模组可以确保某些属性的保底，但是想获取某几个特定属性突出的装备这件事是非常困难的。 这样去拔高装备为属性增幅的门槛，既能提升玩家对装备获取的渴望，也能保证装备的上限几乎是不可估量的。 更多内容再多的内容比如剧情与任务系统那些，鉴于篇幅就不再讨论了，毋庸置疑的是他们同样是整个游戏系统非常重要的一环，只是真的需要步入正题了！ 命运2的战斗设计前面之所以花了超大篇幅去讲究命运2的一些关键元素都是因为任何设计都是有他的出发点与需要保证的体验的，如果单从游戏部分表现与技术出发，可能会忽略掉这个设计其实是围绕某个系统的某一环节所作出的内容。 我们很难通过玩家或者旁观者的身份去推测出这个设计的真正含义，就像很多游戏中的流派与打法，到底是为了产生他们而去做这样的设计，还是纯粹地被玩家给挖掘了出来而设计者不一定能面面俱到去想到。 我希望大家在看这些设计的时候这样的疑惑尽可能少，所以先捋一遍他的大系统，再具体到某个点，去尝试理解这种形成体验闭环的过程，也希望大家能结合起来去思考，找到设计真正的出发点。 命运2Raid中的战斗流程设计副本的流程与节奏是副本设计的基础。命运2的一个raid大概所需要的完整通关时间是一到两个小时，不熟练或者团队有被压光的情况的话可能会需要更久。 这种长时间的流程体验对单个关卡流程设计有种严格的节奏与推进要求。命运2将这样的大流程拆分到了多个关卡中，也就是所谓的箱庭设计。 一个常规raid中，前两关大多是以解密搭配堆怪的关卡设计，然后到第一个Boss关，Boss关同样有解密机制，并且正常的流程需要好2到3波战斗才能解决Boss，之后会到新的解密关，比较经典的都是跳跳乐环节，然后到最终关。这样的拆分保证了关卡间的差异性，并且节奏感非常好，就算花费一到两小时通关也不会觉得乏味。 AI三要素：感知，决策与行为感知，决策与行为这三要素是构成任何类型AI的基础。大部分游戏中的AI都符合这样的一个流程： 感知环境-&gt;获取世界信息-&gt;根据前置规则与要求做出决策-&gt;执行对应行为。 个体AI设计范式 而任何AI都会维护一个Target对象或者一组Target对象，那像在单机游戏中，目标的选取是很直观的，可能绝大部分的敌人AI他们的目标对象都是主角。那在多人PVE游戏中，敌人AI的target选取就有着一定的策略意义在了。 优先最近距离的玩家？还是优先正在对自身造成攻击的玩家？亦或是优先某种职业的玩家？甚至是优先正在做某个关键行为的玩家。对于target的选取是战斗中AI执行行为的第一步，并且这一步将会直接影响整个战斗过程中的难度与玩家体验。还是拿上面的四类基础策略，我们可以看看在战斗中他们各自有着什么样的区别： 优先最近距离玩家：这样的策略最直觉。设想一下反例，如果一个怪物刷新在你的旁边，但它却无视你朝着其它玩家奔去，这样的AI或多或少有些迷惑，并且会有非常大的缺点就是暴露了太多弱点。而优先距离这样的策略既符合直觉，也对玩家的战斗要求做出了限制：我们理所应到优先解决自身最近的敌人，并且需要留意常规刷怪点避免卡位导致一波猝死。 优先对自身造成攻击的玩家：这样的策略在远程攻击AI上显得非常自然，更强调对抗，而且可以引申出OT这样的概念。对于近战AI如果选择这一策略可能会导致他在寻敌过程中暴露过多的弱点，说不定一生都在忙忙碌碌寻找打他的玩家而却做不出任何反抗。 优先某种职业：这就是相对偏策略一点的设计了，有点像狙击手会优先解决对自己威胁最大的那一个。 优先正在做某种行为：这也是很常见的设计，比如某位玩家负责运输某样东西，可能会导致全部怪物集火，而其余玩家就要想法设法保护好这名运送的玩家。这样的策略在一些解密环节往往可以发挥出很好的效果，增加解密体验的难度。就像国王的陨落最终关跳跳乐拾取能量球，这段时间玩家会被远程怪密集攻击，节奏如果不好或者不熟练很容易就会夭折。 当然AI究竟要多Smart，其实是设计者需要考虑与把控的，可能对于一些普通的怪物，他们很容易就能被消灭，甚至你都来不及看到它的AI行为，如果对全部的怪物都大费周章去设计更多的AI行为，对资源，开发与维护的要求都会很高，并且不一定能符合你想展示给玩家的体验。怪物及其AI的设计都应该有一定的梯度，给玩家的带去的体验才更丰富。 命运2中怪物设计有了AI设计的前置理论，再来看命运2中的怪物设计。命运2中的怪物类型非常丰富，除去特殊的Boss，从普通怪到精英怪都从攻击方式，移动方式，属性区别有着丰富的差别。 在某些关卡里可能一波怪物中，会有近战兵，远程兵，盾哥，骑士这样的搭配，再有甚者，命运2中还有这需要特殊类型的buff与枪械才能消灭的怪物，像势不可挡这样的怪物，这就要求玩家在枪械搭配上做出更多的考虑，并且留意怪物类型，遇到盾哥可以采取技能或者狙击枪这样的方式快速解决。 而不同类型的怪物AI也差异了起来，盾哥在收到攻击时优先举盾并且保护附近的怪物，势不可挡在生命值减少时会主动防御恢复高额血量，这些特殊的怪物类型，让玩家在战斗时需要去思考相应的对策，对丰富战斗体验是有非常大帮助的。 Boss的设计往往是高抗高生命值，AI动作大主要以群伤为攻击方式，集合输出阶段： 综上来看，怪物与AI的设计既有减法也有加法，一些简单的怪物可能就AI简单一点，见人就打，那一些精英怪与Boss或许不仅数值要高一点，AI上也应该更丰富一点，可攻可守，决策都由打分这样的机制去综合制定，近战与远程，普通与特殊怪物的AI各自采取何种优先的行为策略。 而这些又将与关卡设计和整个战斗系统相统一，哪些怪物是技能可以简单消灭的，哪些怪物是需要特殊武器去更好解决的，怪物的AI要保证预期的玩家战斗体验，想清楚这些相信就能很好地做出好玩合理的怪物了。 如何实现AI及其表现目前市面上几种常见的游戏AI实现方案：有状态机，行为树，包括越来越得到应用的强化学习AI。而一些特殊的衍生方案，比如GOAP，HTN，模糊逻辑与遗传算法这些，虽然少见，但也有着一定的用途。 好消息是他们的实现我们都不会去聊，如果感兴趣，相关的插件比如Unity中的Behavior Designer，腾讯开源的Behavic，UE自带的Behavior Tree，都是非常棒的行为树解决方案，一些其他的，在Github上也或多或少能找到相关实现与参考。 我们主要来聊应用，即如何通过这些非常好的工具去实现我们的设计方案。为了方便，我们也只聊行为树这一方案。这里假设大家已经对相关技术有一定的认知，如果没有，可以参考我文章最后的引用进行学习。 首先抛出一个概念，行为树是一种有向树，而有向树结构可以转化为有向无环图。 到这里可以得到一个结论，那就是这样的结构天生与有环AI行为设计方案相悖。然而大部分AI的设计方案中，跳转这个操作是非常常见的，一个简单的例子是在攻击状态中的可打断阶段收到伤害需要跳转到受伤状态，这样的跳转会导致流程图中环的出现。 这就要求我们在做AI策划案时尽可能少地去出现环形结构，如果可以，把这样的跳转拆进某个状态的子状态中，或者叫某个节点的子节点中，宁可多一点消耗，也要保证树的结构清晰，这是AI行为树流程的设计规范。 再之后，明确整个AI行为的流程，一个正常的方式是先获取世界信息，计算先决条件，寻路，避障，追逐玩家，战斗，战斗间隔行为等等。当然这一块肯定是见仁见智，每个AI的流程可能不仅相同，只是大方向上应该是如此。 UE5的Lyra中射击AI的行为树结构 再到表现，明确所需求的动画资源，特效。而一些非常常见的动画方案比如Avatar Mask，Motion Warping或者程序化动画，都是需要有一定的认知与了解的，这样才能根据AI设计去给出良好的动画设计与解决方案。当然动画的实现这一块因为还在做相关的学习，等到最后再补充好了，如果还记得的话。（咕咕咕） 写在最后因为平时学习的时间有限，很难想象这篇文章我拆散在了好几天的夜晚最终以6700字结束。可能自身经验有限，在写这样的文章时往往感觉思维很发散，所以我用更不专业的方式去编写了大部分内容，希望以自己的一点拙见去引出大家的思考，也希望这些内容没有偏离设计的核心。我并不是一个专业的游戏策划，也不是超1000小时的命运2大拿，所以文章如有过错，还请多多指正~也欢迎大家在评论区进行讨论！ 引用腾讯游戏学堂：FPS技巧详尽拆解","categories":[{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/categories/Game-Design/"}],"tags":[{"name":"Destiny2","slug":"Destiny2","permalink":"https://wyryyds.github.io/tags/Destiny2/"},{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/tags/Game-Design/"}]},{"title":"UE5 Lyra全系统拆解分析","slug":"UE5-Lyra全系统拆解分析","date":"2023-08-06T12:36:22.150Z","updated":"2023-09-07T15:52:13.851Z","comments":true,"path":"2023/08/06/UE5-Lyra全系统拆解分析/","link":"","permalink":"https://wyryyds.github.io/2023/08/06/UE5-Lyra%E5%85%A8%E7%B3%BB%E7%BB%9F%E6%8B%86%E8%A7%A3%E5%88%86%E6%9E%90/","excerpt":"","text":"填完坑就补 References知乎：Lyra动画系统","categories":[{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/categories/UE5/"}],"tags":[{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/tags/UE5/"},{"name":"Lyra","slug":"Lyra","permalink":"https://wyryyds.github.io/tags/Lyra/"}]},{"title":"简析Unity下的游戏热更新技术","slug":"简析Unity下的游戏热更新技术","date":"2023-07-09T14:27:00.538Z","updated":"2023-08-14T14:07:07.139Z","comments":true,"path":"2023/07/09/简析Unity下的游戏热更新技术/","link":"","permalink":"https://wyryyds.github.io/2023/07/09/%E7%AE%80%E6%9E%90Unity%E4%B8%8B%E7%9A%84%E6%B8%B8%E6%88%8F%E7%83%AD%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF/","excerpt":"","text":"写完就填坑","categories":[{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/categories/Unity/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/tags/Unity/"},{"name":"xlua","slug":"xlua","permalink":"https://wyryyds.github.io/tags/xlua/"},{"name":"ILRuntime","slug":"ILRuntime","permalink":"https://wyryyds.github.io/tags/ILRuntime/"},{"name":"HyBridCLR，热更新","slug":"HyBridCLR，热更新","permalink":"https://wyryyds.github.io/tags/HyBridCLR%EF%BC%8C%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"对C#与C++中事件机制的解析","slug":"事件类型的解析","date":"2023-04-13T07:21:11.150Z","updated":"2023-04-18T11:01:40.647Z","comments":true,"path":"2023/04/13/事件类型的解析/","link":"","permalink":"https://wyryyds.github.io/2023/04/13/%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%90/","excerpt":"","text":"在对C++项目的学习中，也是慢慢接触到了C++中的事件机制。之前最早的博客里面也是有我大一曾经对C#中的委托与事件做的笔记，现在把两者重新放在一起进行比较讨论。 C#中的事件机制在提到C#中的Event时，有必要先认识一下C#的委托(delegate)： C#中的Delegate在C#中，委托是一种类，它包装了一个或者多个方法，并且允许以类似函数调用的方式来调用这些方法，类似C++中的函数指针。下面是委托的几种显式声明格式： 1.不含参数列表，使用void作为返回类型的委托定义与声明格式： public delegate void MyDelegate1(); public MyDelegate1 handler1 2.接受一个int类型参数，使用void作为返回类型的委托定义与声明格式 public delegate void MyDelegate2(int param); public MyDelegate2 handler2 3.接受一个int类型与一个string类型的参数，使用int作为返回类型的委托定义与声明格式： public delegate int MyDelegate3(int param1,string param2); public MyDelegate3 handler3 4.接受两个泛型参数，返回值为泛型的委托定义与声明格式： public delegate TResult MyDelegate4&lt;in T1, in T2, out TResult&gt;(T1 param1, T2 param2); public MyDelegate4&lt;int,string,int&gt; handler4 委托的声明方式远不止以上几种，他跟函数的声明一样的灵活，只需要加上delegate关键词即可。C#也内置了几种泛型委托提供了更简洁的委托声明方式，我们可以使用Action与Func简化上面的几种声明格式，其中第四种就是Func的一种定义： 1.不含参数列表，使用void作为返回类型的委托声明格式： public Action handler1; 2.接受一个int类型参数，使用void作为返回类型的委托声明格式 public Action&lt;int&gt; handler2; 3.接受一个int类型与一个string类型的参数，使用int作为返回类型的委托声明格式： public Func&lt;int,string,int&gt; handler3; 4.接受两个泛型参数，返回值为泛型的委托声明格式： public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 param1,T2 param2); public Func&lt;int,string,int&gt; handler4; C#规定，Action用来声明无返回值类型委托，Func用来声明有返回值委托。在实际开发中，我们都应该尽量使用这种方式来对委托进行声明，他们的优点显而易见，一是避免了显式委托声明的繁琐，二是对委托是否具有返回值进行了界定，非常的清晰。 对上面第一种情况的委托进行使用： 12345678910111213141516171819//声明委托public Action handler1;//无参数，void返回类型的函数声明public void ConsoleString()&#123; Console.Writeline(&quot;调用handler1&quot;);&#125;//将方法添加到委托中。handler1 += ConsoleString;//调用委托//handler1();//显式调用委托handler1?.Invoke();//输出:调用handler1 从对于第一种委托的声明与使用，我们可以发现似乎委托就是函数指针，调用该委托等价于调用该函数方法。在单播的情况下确实是这样，考虑下面这种情况： 1234567891011121314151617181920212223//声明委托public Action handler1;//无参数，void返回类型的函数声明public void ConsoleString()&#123; Console.Writeline(&quot;调用handler1&quot;);&#125;public void ConsoleNumber()&#123; Console.WriteLine(114514);&#125;//将方法添加到委托中。handler1 += ConsoleString;handler1 += ConsoleNumber;//显式调用委托handler1?.Invoke();//输出:调用handler1114514 这就是委托的多播，我们可以发现委托会调用所有已添加的方法，据此我们也可以推测委托类的实际实现，它可能包含如下几个部分： 对目标方法的引用； 如果目标方法是实例方法，那它应该还需要持有包含目标方法的对象的引用； 支持多播委托的链表容器；为什么选择链表呢，首先是为了支持动态大小，并且链表的删除是O(1),我们如果需要频繁添加和移除方法链表的效率肯定最高，最后是链表的结构很灵活，链表节点可以存储任意类型的方法引用，并且链式调用可以通过修改指针来改变调用顺序。 事实上在远古时期的.Net Framework中，委托的实现是基于函数指针的，但是函数指针的缺点很明显，不支持多播委托，并且安全性较弱，从.Net Framework2.0之后，委托的实现就变成了一个委托类，在编译时自动生成，而委托类的实现.Net并没有公开，但是实际核心实现跟我们推测的，应该是大差不差的。 对于上面的代码，我们还可以使用lambda表达式来简化这两个函数的声明： 12345678910111213//声明委托public Action handler1;//利用lambda表达式将方法添加到委托中。handler1 += () =&gt; &#123; Console.WriteLine(&quot;调用MyDelegate1&quot;); &#125;;handler1 += () =&gt; &#123; Console.WriteLine(114514); &#125;;//显式调用委托handler1?.Invoke();//输出:调用handler1114514 再来看一下有返回值类型的Func委托,对于我们定义的第三种委托进行使用，同样采取lambda表达式简化函数声明过程： 1234567891011121314151617181920212223242526272829 public Func&lt;int, string, int&gt; handler3; public static x = 0; handler3 += (param1, param2) =&gt; &#123; int sum = param1 + x++; Console.WriteLine(param2 + &quot;:&quot; + sum); return sum; &#125;; //在只添加一个函数的情况下调用 handler3?.Invoke(0, &quot;填入的数字加上x后是&quot;); handler3 += (param1, param2) =&gt; &#123; int sum = param1 + x++; Console.WriteLine(param2 + &quot;:&quot; + sum); return sum; &#125;; //在添加了两个一模一样的函数的情况下调用 var t = handler3?.Invoke(0, &quot;填入的数字加上x后是&quot;); //输出返回值 Console.WriteLine(&quot;最终返回值是：&quot;+t);//全部输出:填入的数字加上x后是:0填入的数字加上x后是:1填入的数字加上x后是:2最终返回值是：2 对于这个Func委托，我们添加了两个一模一样的方法，即对于同一个方法添加两次。我们发现在添加了这个方法两次的时候，我们执行委托将会执行两遍这个函数，然而委托的返回值并不是一个函数返回值列表int[]，而仅仅是一个int，从这里我们可以知道，对于一个有返回值的委托，它的最终返回值将会是最后一次调用的方法的返回值。最后我们来讲一下委托的缺点： 委托的缺点： 委托会造成内存泄漏：委托会引用一个方法，如果这个方法是一个实例方法（非静态方法）的话，那么这个方法必须隶属于一个对象，拿一个委托引用这个方法，那么这个对象必须存在在内存中，即便没有其他引用变量引用这个对象了，这个对象的内存也不能被释放，因为一旦释放，内存就不能再间接调用对象的方法了。 多播委托同样在维护上存在一定的困难性，容易导致所有的方法重置。我们在上面所有的例子中给委托添加方法都是使用的+=，但是委托可以使用=赋值，一旦使用了等号赋值，委托之前添加的所有函数将会被清空，也就是会从多播变成单播，并且不会有任何的报错，而如果大项目中出现了这样的小错误，排查起来也是需要费点功夫的。 嵌套调用可读性差 讲到这里，C#中的委托差不多就讲完了，那什么又是C#中的事件呢，委托看起来已经很已经很方便了，为什么还要事件呢？ C#中的Event事件的本质就是委托字段的包装器，声明的关键词为event。对于显式声明的委托，事件的声明方式如下： 12345678910111213//定义一个不含参数列表，没有返回值的委托public delegate void MyDelegate1();//声明该委托的字段public MyDelegate1 handler;//声明该委托类型的事件public event MyDelegate1 actionEvent;//定义一个含有两个参数，返回值为int类型的委托pulic delegate int MyDelegate2(int param1,param2);//声明该委托的字段public MyDelegate2 handler;//声明改委托类型的事件public event MyDelegate2 funcEvent; 同样可以使用Action与Func来简化声明： 12345//声明一个不含参数列表，没有返回值的事件public event Action actionEvent;//声明一个含两个参数，返回值为int类型的事件public event Func&lt;int,int,int&gt; funcEvent; 事实上，我们仅仅是多加了一个event关键词来声明该委托的事件类型，事件的出现就是为了解决多播委托的维护问题，事件只允许通过+=或者-=来访问进行方法的添加与删除，而不允许通过=赋值，实际上事件完整的声明方式类似属性，有add与remove两个事件处理器，并且事件更加安全，不允许外部去触发事件，事件还可以使用！=这个语法糖来进行判空。C#中的事件就是对委托实例的阉割，让它更安全。 这些大概就是C#中委托与事件的大部分内容，在实际开发中，他们有着非常广泛的使用场景，比如回调函数的实现，消息的传递，观察者模式的实现，异步方法与面向事件的设计模式……利用好事件系统可以为项目提供很大的灵活性，是开发中不可或缺的一部分。 C++中的事件机制我们在上面反复提到一个词：函数指针，它是在C++中实现委托与事件机制的关键。C++并没有像C#那样内置的委托类型来处理事件，而需要自己去管理函数指针，并且利用回调函数的方式来实现。考虑最简单的实现： 1234567891011121314151617// 定义函数指针类型：传入一个int参数,无返回值的函数指针typedef void (*EventHandler)(int);//声明一个函数指针对象eventHandlerprivate EventHandler eventHandler;// 定义格式匹配的事件处理函数void MyEventHandler(int arg)&#123; std::cout &lt;&lt; &quot;Event Handler: &quot; &lt;&lt; arg &lt;&lt; std::endl;&#125;//为函数指针赋值eventHandler = MyEventHandler;//执行事件eventHandler(10);//输出Event Handler:10 直接使用函数指针有不少的缺点： 无法捕获上下文信息，函数指针只能指向静态函数或者全局函数； 不支持多态，即函数指针只能指向固定的函数签名； 语法相对繁琐，可读性差； 安全性差，函数指针没有类型检查与空指针检查。 在C11之后，标准库提供了一个通用的函数封装类：std::function&lt;返回值类型(参数类型1，参数类型2，...)&gt; 变量名，它可以说是升级版函数指针，可以用于存储、传递和调用各种类型的可调用(函数)对象（例如函数指针、成员函数指针、lambda 表达式等），所以上面的代码可以改成如下形式： 123456789101112131415//声明function对象std::function&lt;void(int)&gt; eventHandler;// 定义格式匹配的事件处理函数void MyEventHandler(int arg)&#123; std::cout &lt;&lt; &quot;Event Handler: &quot; &lt;&lt; arg &lt;&lt; std::endl;&#125;//赋值eventHandler = MyEventHandler;//执行事件eventHandler(10);//输出Event Handler:10 它几乎解决了所有函数指针的缺点： 支持捕获上下文，可以捕获局部变量与this指针，可以实现闭包； 支持多态，可以保存普通函数，函数指针，lambda表达式，成员函数等各种函数对象； 声明格式清晰，可读性好； 严格的类型检查； std::function的底层实现的关键是多态技术与类型擦除，通过使用模板和虚函数来实现对不同类型的函数对象进行类型擦除和统一的调用接口。简单的一个function类型同样不支持多播，我们需要手动实现一下事件多播，考虑最简单的实现方式，我们利用一个vector容器存储function对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#头文件// 事件处理器的类型定义using EventHandler = std::function&lt;void()&gt;;class Event&#123;public: // 添加事件处理器 void AddHandler(const EventHandler&amp; handler) &#123; handlers.emplace_back(handler); &#125; // 移除事件处理函数 void RemoveHandler(const EventHandler&amp; handler) &#123; for (auto it = handlers_.begin(); it != handlers_.end(); ++it) &#123; if (*it == handler) &#123; handlers_.erase(it); break; &#125; &#125; &#125; // 触发事件 void Invoke() &#123; for (const auto&amp; handler : handlers) &#123; handler(); &#125; &#125;private: std::vector&lt;EventHandler&gt; handlers; void OnEvent1() &#123; cout &lt;&lt; &quot;Event 1 handled&quot; &lt;&lt; endl; &#125; void OnEvent2() &#123; cout &lt;&lt; &quot;Event 2 handled&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Event event; // 添加事件处理器 event.AddHandler(OnEvent1); event.AddHandler(OnEvent2); // 触发事件 event.Invoke(); return 0;&#125;//输出Event 1 handledEvent 2 handled 在这里我们手动实现了一个Event类，并且支持了函数事件的添加与移除以及触发。当然这是最简单也最粗糙的实现，我们可以发现在对事件的移除上的时间复杂度是O(n),在涉及频繁添加和移除事件处理函数的场景中性能是比较差的，而常见的容器里面，map跟list的删除性能是比较好的，参考C#的委托类的实现思路，我们可以使用list作为容器来对上面代码进行修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;list&gt;using namespace std;// 事件处理函数类型using EventHandler = function&lt;void()&gt;;class Event&#123;public: // 添加事件处理函数 void AddHandler(const EventHandler&amp; handler) &#123; handlers_.push_back(handler); &#125; // 移除事件处理函数 void RemoveHandler(const EventHandler&amp; handler) &#123; handlers_.remove(handler); &#125; // 触发事件 void Invoke() &#123; for (const auto&amp; handler : handlers_) &#123; handler(); &#125; &#125;private: list&lt;EventHandler&gt; handlers_;&#125;;int main()&#123; Event event; // 添加匿名事件处理函数 event.AddHandler([]() &#123; cout &lt;&lt; &quot;Event 1 handled&quot; &lt;&lt; endl; &#125;); event.AddHandler([]() &#123; cout &lt;&lt; &quot;Event 2 handled&quot; &lt;&lt; endl; &#125;); // 触发事件 event.Invoke(); // 移除匿名事件处理函数 event.RemoveHandler([]() &#123; cout &lt;&lt; &quot;Event 1 handled&quot; &lt;&lt; endl; &#125;); // 再次触发事件 event.Invoke(); return 0;&#125;//第一次输出Event 1 handledEvent 2 handled //第二次输出Event 2 handled 这样就算是实现了一个不错的事件对象，支持多播并且性能可观，我们可以利用它来实现C++中的消息机制。当然这里就不过多描述了，感兴趣的朋友可以自己动手试一试 。我们还能使用std::bind来进行参数绑定： 12345678910111213141516171819int main()&#123; Event event; int localVar = 114514; // 局部变量 // 使用 bind 将匿名函数与局部变量进行绑定 event.AddHandler(bind([](int value) &#123; cout &lt;&lt; &quot;Event handled with local variable: &quot; &lt;&lt; value &lt;&lt; endl; &#125;, localVar)); // 触发事件 event.Invoke(); return 0;&#125;//输出Event handled with local variable:114514 利用std::function与std::bind可以实现灵活可复用的函数对象与回调，在大部分回调函数的实现场景中我们都应该选择这样的实现。我们也可以发现，上面的多播是针对单一函数对象的多播，即返回值与参数列表都匹配。事实上，我们还可以利用模板去实现对任意参数的函数对象的多播，更甚者，还可以利用模板与元组std::tuple，实现多返回值，多参数的事件多播。虽然我们的实现非常自由，但是这样处理对代码的可读性与维护都会造成比较大的困难，在实际开发中还是需要按量实现。 相信到了这里，对于C#与C++中事件机制的处理的差异，已经非常明显了： C#中，内置了delegate与event类型，存在多播机制，使用非常方便，而在C++中，我们需要手动管理内存，并且需要利用容器对std::function进行封装，才能实现类似C#的委托多播效果，当然它更加灵活，在性能上也是更加可控的。 写在最后：对Lambda表达式的讨论Lambda表达式作为在C#与C++中都很常用的匿名函数实现方式，在上文中也是反复提到，我们有必要对它的实现与性能做一定的了解。 在C#中，Lambda 表达式的实现是通过编译器将 Lambda 表达式转换为委托类型或表达式树，并在运行时执行。在编译时，编译器会生成一个匿名方法，并将 Lambda 表达式转换为一个委托类型的实例，其中包含了对外部变量的引用。在运行时，Lambda 表达式可以像其他委托一样被调用，并在执行时访问捕获的外部变量的值，形成了闭包。考虑下面这种实现： 123456789101112131415public class TestClass&#123; private int instanceInt; public void Test() &#123; for (int i = 0; i &lt; 100; i++) &#123; Action act = () =&gt; &#123; int x = instanceInt; &#125;; &#125; &#125;&#125; 在匿名方法中声明一个int变量x，去捕获实例字段instanceInt，并尝试在循环中对一个委托对象赋值，这样的写法会导致发生100次的内存分配。如果 lambda 表达式使用了实例方法或实例属性，而不是静态方法或静态属性，那么在每次执行 lambda 表达式时，都会为 lambda 表达式分配一块内存来存储实例方法或实例属性的引用。这样的做法将会引起性能问题。 如果捕获局部变量，比如这样： 12345678910111213public class TestClass&#123; public void Test() &#123; for (int i = 0; i &lt; 100; i++) &#123; int localInt = 0; Action act = () =&gt; &#123; int x = localInt; &#125;; &#125; &#125;&#125; 它甚至会导致200次的内存分配，编译器会为每一次捕获的局部变量创建匿名类对象来保存该局部变量，然后使用匿名方法去创建Action对象并赋值给act。 而我们可以通过增加参数数量去传递要捕获的参数来避免对外部变量的访问从而优化掉这些多余的内存分配。对于上面的代码，修改如下： 123456789101112131415public class TestClass&#123; public void Test() &#123; for (int i = 0; i &lt; 100; i++) &#123; int localInt = 0; CallAction(localInt,(param) =&gt; &#123; int x = param; &#125;); &#125; &#125;&#125; 这样，整个过程就只会导致1次内存分配。 在C++中，Lambda表达式的使用同样有着需要注意的问题。 12345678910111213141516171819std::vector&lt;int&gt; myVector = &#123;1, 2, 3, 4, 5&#125;;// 使用引用捕获的 lambda 表达式auto lambdaWithRefCapture = [&amp;myVector]() &#123; std::cout &lt;&lt; &quot;Lambda with reference capture: &quot;; for (const auto&amp; val : myVector) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;;// 不使用引用捕获的 lambda 表达式auto lambdaWithoutRefCapture = [myVector]() &#123; std::cout &lt;&lt; &quot;Lambda without reference capture: &quot;; for (const auto&amp; val : myVector) &#123; std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;; 虽然最终的输出一致，但是两者的性能存在差异，使用引用捕获，直接访问了外部的 myVector，没有进行复制或移动操作，而 lambdaWithoutRefCapture 没有使用引用捕获，会进行了一次 vector 对象的复制操作，从而产生了额外的内存开销。 同时在C++中，使用Lambda表达式更应该小心捕获对象的生命周期，避免访问已销毁对象，而对于指针对象，我们都应该使用智能指针进行管理，让我们更少地遇到内存泄漏这样的问题。 参考：知乎-芯片烤电池：C++回调函数及std::function与std::bind 自然有猫仙人：C#委托与匿名方法内存分配总结 有道云笔记：委托的底层机制实现 知乎-Ruyi Y：C#委托与事件","categories":[{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/categories/C/"},{"name":"C#","slug":"C/C","permalink":"https://wyryyds.github.io/categories/C/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"}]},{"title":"2023春招总结","slug":"2023春招总结","date":"2023-03-29T07:30:27.797Z","updated":"2023-06-15T13:11:30.725Z","comments":true,"path":"2023/03/29/2023春招总结/","link":"","permalink":"https://wyryyds.github.io/2023/03/29/2023%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"行业的寒气是否退散尚不得知，但就2023年春招的形势来看，面向24届的实习岗还是不在少数，几乎各家都有在积极筹备暑期实习与一些零散的日常实习招聘，总的而言身边很多24届的朋友都有不错的进展。尽管博主还是25届，但是抱着试一试的心态，还是投递了几家公司的春招，幸运的是，也是在最后拿到一些offer，也更加明确了以后需要提升的方向。 首先说一下投递情况：腾讯：投递后无消息（简历挂，推测是去年的面评很差） 吉比特：简历挂。 米哈游：简历挂。 字节朝夕光年：简历挂。 剑心互娱：笔试挂。 心动游戏：拒绝笔试。 疯狂游戏：拒绝笔试。 育碧成都：笔试+一轮技术面，一周后hr通知需求变化无hc挂。 西山居：笔试+一轮技术面，一面挂。 网易互娱：HR面+一轮技术面，无后续默认挂。 网易雷火：笔试+一轮技术面，一面挂。 ————–5.9更新———– 西山居：seed免面试通过 英雄游戏：流程中 电魂游戏：5.5投递，当天hr电话联系约面，5.6日面试，半小时后hr通知通过… 跌跌撞撞也算是春招有成果了（开森） 这样一看感觉好像挺挂彩的，也确实挺打击的，总觉得自己的工程能力似乎还不错，但其实真正去招聘才知道自己的竞争力有多差。尽管投递的公司没有几家，但那段时间整个人都非常折磨：等通知，做笔试，补八股，面试后抱着期待的心情等结果。也确实挺丢人的，刚面完的那个晚上会有点睡不着觉，总是感觉似乎答得还不错，会不会第二天就OC，结果却往往让人失望。到后面也算是慢慢有了磨练的感觉，无论面试反问面试官给你什么样的反馈，都应该明白横向是不可缺少的环节，所以也不必抱有太大的期待。 由于笔试的内容我没有特意去记录，所以笔试题就不分享了，主要是把各家的面试内容进行记录与总结，也希望这一部分能对看到的人起到帮助。项目部分的内容还是见仁见智，根据每个人的项目经历与实习经历应该做出区分。 面试内容与答案育碧成都1.聊一下实习期间具体用行为树做了什么。主要是用行为树去设计几类怪物AI，用自拓展节点去组织具体的行为模块，并且参考htn的形式对行为模块做了分层处理，同时做了数据分离。 2.对于行为树中的各个模块是如何组织设计的。将行为分类，划分通用子树，设置明确的行为条件与特殊状况的事件处理机制…. 推荐参考：AI的被动式处理 3.AI感知器，寻路以及战斗部分的具体实现。推荐参考： AI分享站 烟雨：基于行为树的技能系统 GDC最后生还者中的近战AI设计 4.表现资产的配置问题。动画的处理方式；战斗表现是用timeline的形式去处理，还是用其他方式去生成。 推荐参考： 行为树的常用动画配置方式 动画与控制系统的讨论 5.数据分离做了哪些工作，共享行为树的设计与使用场景用一个共享单例管理某种类型行为树的通用数据，数据由SO配置，供多个AI实体访问，实体做到逻辑与表现分离，每个实体的行为树只需要执行逻辑部分。这种设计在后端同样适用。在场景中有较多同类型怪物的情况下使用，可以节省开销。 推荐参考：黑板与共享数据 6.行为树的GC问题行为树的数据类型设计，比如shared类型数据是否会拆箱装箱，利用泛型的设计可以避免拆箱装箱。 行为树的加载需要反序列化，可能会引发GC问题。 推荐参考： Behavior Designer官网讨论的行为树加载问题 行为树加载的反序列化性能问题 7.讲一下项目中对象池的工作流程，做了哪些接口，如何设计。工作流程：池初始化-&gt;拿取对象-&gt;容量检查-&gt;回收机制-&gt;回收….. 一个通用性强的对象池除了需要有基础的拿取回收接口外，最好定义一些生命周期函数的委托方法供外部注册，比如OnGetBefore()，OnReleaseBefore()等等，也要有良好的扩容收缩机制，类比stl中的vector，很值得一提的是不同数据容器的选取会对池的各种操作产生影响，同时也会影响到池中对象的活跃度，类比栈对象池与队列对象池，队列对象池的对象平均活跃程度是更高的（栈底的对象可能永远不会被拿取）。 推荐参考：基于队列的对象池 8.项目中的全局消息机制如何实现，消息从广播分发到相应执行的过程，中断与注销机制。利用枚举加字典可以很快的设计好需要的数据结构。提供给外部需要的注册与注销方法，响应时遍历指定消息类型的整个订阅列表进行invoke。参考的话等我以后补一篇相应内容的帖子好了（鸽）。 9.项目中UI的搭建，注意过相关开销没有。对于UI的搭建，不同项目处理的方式不同，不做赘述，只是需要简单注意一下基本原则与优化即可。 推荐参考： MVI响应式架构UI 《Unity3D高级编程：主编手记》：UI优化 10.Unity中资源的动态加载与本地保存。我在项目中用得比较多的加载方式还是Resource，本地保存的是用的PlayerPrefs。 推荐参考：Resource与AB包的区别讨论 11.2D游戏中的AI如何设计，做了哪些模块。寻路上直接用的Pathfinding插件，其余的部分用的状态模式处理的AI行为。 12.C#中用List做对象池怎么处理拿取与回收，用链表怎么实现对象池。碰巧的是我确实也用List做过对象池，实际上选什么类型的数据容器都是大差不差，而对于List的对象池的拿取其实是想问你优化。最直接的优化策略就是双指针，一个指针记录上一次拿取的index，需要拿取的时候往后拿，同时每次做取余操作防止溢出。另一个指针在回收时指向最后被回收的index，判断池满的条件就是前者追上后者。而链表实现对象池在内存池中的应用非常常见， 推荐参考：STL空间配置器解析 总结：育碧的面试确实很出人意料，没有问很多的八股，更多的是考察你对项目的理解以及你的开发能力，包括对相关部分的深度。是三个面试官一起问，所以压力很大，但是总的而言整个面试很务实，体验也是非常不错，遗憾的是没有oc，hr后续通知需求变化，应该就是横向比较所以筛掉了，毕竟25届加双非本，确实不具备很强的竞争性。 西山居：剑侠世界三项目组1.C++与C的区别虽然这个问题可以扯非常多的东西，但是并不建议在面试官面前卖弄见解打开你的话匣子。最简单直接的就是说明C++在oop上的优越性以及C++的新特性，C++几乎是C的超集。 2.面向对象的三大特性，什么是多态基础中的基础但是重点中的重点。 3.对象的内存模型头部虚指针，按照类的继承顺序与声明顺序布局。 4.虚函数的实现方式，虚表的建立时间虚函数的实现通过虚表与虚表指针，虚表在编译时就已经确定。 5.深拷贝与浅拷贝浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存；深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。 6.父类构造函数能不能调用虚函数可以，但是会屏蔽多态机制。因为在父类的构造函数中子类特有的成分尚未初始化。 7.值传递与引用传递传引用直接访问对象，不会产生拷贝，传值的拷贝可能造成很大开销，比如传递vector类型变量。 8.拷贝构造函数的常见形式构造函数加引用参数 9.delete与delete[]new申请的内存，释放时用delete；使用new [ ]申请的内存释放时要用delete [ ]，否则可能产生内存泄漏 10.vector与list有什么区别，各自的使用场景两种的区别还挺大的，但是面试一直很喜欢问这个问题。 list是由双向链表实现的，内存空间是不连续的。由链表的实现原理可知： 优点：插入和删除效率较高。只需要在插入的地方更改指针的指向即可，不用移动数据。 缺点：List查询效率较低，时间复杂度为O（n） vector拥有一段连续的内存空间，并且起始地址不变,与数组类似： 优点：便于随机访问，时间复杂度为O（1）， 缺点：因为内存空间是连续的，所以在进入插入和删除操作时，会造成内存块的拷贝，时间复杂度为O（n）。 使用场景跟据需求操作的时间复杂度去确定。 11.红黑树与平衡二叉树的区别不描述直接上链接了。推荐参考：知乎帅地：红黑树与平衡二叉树区别 12.树上的查找时间复杂度分析推荐参考：二叉树，二叉搜索树，平衡二叉树与红黑树的时间复杂分析 13.哈希表的实现方式常见的有桶数组加链表 14.哈希冲突解决方法，列举3个上拉链法，开放寻址法，再哈希法….. 15.push_back跟emplace_back的具体区别emplace_back() 函数在原理上比 push_back() 有了一定的改进，包括在内存优化方面和运行效率方面。内存优化主要体现在使用了就地构造（直接在容器内构造对象，不用拷贝一个复制品再使用）+强制类型转换的方法来实现，在运行效率方面，由于省去了拷贝构造过程，因此也有一定的提升。 16.aoi算法MMORPG游戏中最常见的优化算法之一，推荐参考： 知乎：AOI算法 17.navmesh的原理主要是三角形寻路网格的构建与基于该网格的A*寻路方法。 推荐参考： Github：recastnavigation 陆泽西：架构设计NavMesh寻路 18.A*算法的具体实现与优化非常经典的高频次问题。 推荐参考： 阿里云：A*算法详解 A*算法的几种优化 19.行为树模块的的设计与实现20.讲一下全局消息机制的实现重复的问题就不再复述了，C++的八股推荐参考：知乎Steven王：游戏开发面经汇总 总结：不是很走运，面试官在一开始就跟我坦言他是服务器开发方向，而我是客户端。整个面试过程非常的轻松愉悦，并且值得开心的是面试官也给了我一个不错的评价，虽然没有后续，但确实是一次非常好的面试体验。 网易互娱：在线游戏事业部1.讲一下行为树模块的实现2.讲一下你的全局消息系统的实现3.讲一下你在项目中如何设计UI模块的从需求出发，根据功能设计层级面板，分离数据的处理与表现，管理器提供泛型接口。 4.UI的多界面打开后返回上一级实现听到返回上一级直接栈，非常经典的问题。 5.实现一个面板管理器的Open方法主要是考虑相似面板实现相同的接口以及利用继承管理子元素。然后open()方法中接受接口类型或者基类。 6.委托的本质是什么委托是一个类，有invoke方法…. 总结：感觉得到面试官并不是很赞成我大二过去实习。问得也比较简单，可能也是因为不会lua的原因，与项目需求并不是特别匹配。 网易雷火：逆水寒项目组（补档）1.项目中的UI如何搭建的2.对象池的实现3.项目中的问题与瓶颈在跟面试官说做过肉鸽类游戏后面试官一针见血的指出了项目中是不是存在性能问题，确实是在场景中子弹与怪物过多的情况下会遇到帧率降低游戏卡顿的情况，面试官也试着问了一下有没有做优化处理，回答的是通过游戏设计层面去限制了子弹射速并且加速了回收策略，但是情况确实还是会出现。也被面试官吐槽了一句做得太粗糙了。 4.帧率低是因为场景中物体过多还是因为生成与销毁太密集当时完全没有去做相关的测试，所以没有答上来。也确实在遇到这种情况需要去用profile做性能检测。 5.四叉树优化场景中物体的碰撞检测还是基于上面卡顿的情景，提到可以用二叉树或者四叉树做碰撞检测优化。 推荐参考：KillerAery：空间数据结构 6.做过多少种UI，用过什么框架做过背包，滑动列表，功能性界面等等还有基础UI，框架的话说用过MVC跟MVI，还有消息机制的UI，但是面试官并没有再细问。 7.对背包系统做优化（同一面板有大量UI元素如何避免加载卡顿）提问场景是背包中有大量元素，如果打开时发现加载卡顿如何优化。当时的回答主要是从预加载，缓存队列跟对象池进行的分析，感觉面试官还比较满意。 预加载：在很有可能打开背包的情况的下提前进行部分元素的预加载，比如战斗结束领取完奖励这种情景，很有可能会打开背包查看物品，进行预加载，设置一个时间戳假如到时间没有打开背包再销毁…. 利用缓存队列分批放在多帧内加载，按照批次对物品进行加载避免某一帧大量元素的加载。 对象池：牺牲内存保留部分背包内UI元素，打开背包时只需进行初始化。 8.如何降低draw call当时被问到一瞬间很懵，然后明白可能面试官可能希望对背包系统的优化是从引擎层面来讲。就答了网格合并跟批处理，然后就掉进了陷阱。 9.动静态图集基于第七题与第八题的情景，面试官问背包内有大量UI图标如何减少draw call，还问我日常开发有没有关注过，我诚实地说了没有。回答说把图标全部划分到同一个图集里，优化批处理降低draw call。面试官就继续说如果图标元素有很多张图集，然后这些图标都来自不同的图集，那draw call并没有得到优化，这种情况怎么办。我当时就懵懵的了，答了个分类处理图标并把背包按类别查看可以提高命中率，他问还有什么更好的方法吗，当时脑子一抽没想到动态图集，然后面试官就笑着说你做过图集没有，我说没有，他说还可以运行时动态生成图集。我才恍然大悟，直接在运行时把当前页面的图标动态合并到一张图集上就行。 10.全局消息机制的实现11.行为树模块的实现12.技能系统与角色属性管理问了怎么实现的技能系统，回答每个技能都是一个单独类，然后带有各自的属性与一些依赖条件，与角色的属性绑定，计算单独放在属性管理器里面。 13.数据配置与工具开发用得最多的还是SO，策划直接在引擎里面配置数据，因为没有后端采取的是最方便的方法。然后面试官问有没有为行为树或者其他系统做过数据配置的工具跟一些可视化工具。巧合的是因为之前开发的时候都有考虑过，回答说都做了数据分离方便策划改数据，可视化在战斗上做了，也算是半个工具吧。 14.介绍Unity的动画系统介绍完还问我对Unity的动画系统哪些最熟悉，做过哪些动画到了什么地步。这问题太宽泛了就不贴答案了，感兴趣可以问gpt。 15.Avatar Mask的使用经典上下半身分离的动画功能。这一点的话官方文档就有很好的说明：Unity：AvatarMask 16.动画混合树与分层动画推荐参考：Unity动画系统详解 17.骨骼动画原理当时回答了一堆概念，然后面试官说方式是这么个方式，怎么实现了解过吗，答没有。 推荐参考：骨骼动画的实现 18.骨骼如何带动蒙皮也是答了一堆概念然后问我蒙皮算法实现，也不会。 推荐参考：线性蒙皮分解算法 19.会不会python会但不多，不想挖坑直接说了不会。 20.有没有写过ECS跟jobsystem了解但没有写过。推荐参考：烟雨：Unity DOTS 21.讲讲UnityShader说了一些工作流与UnityShader的设计，但是实际开发项目中没有用过，只跟书实现过效果，被面试官批评了简历应该写了解而不是熟悉。 22.对简历的一些建议23.讲讲对引擎基础架构的认识聊了一些104学到的东西，已经被问麻了当时不知道该怎么回答了。 24.对开发哪些模块最感兴趣25.讲一下C++1126.右值引用与左值引用当时脑子一团浆糊，说了一点简单的然后其余的记不清了。 推荐参考：详解左值引用与右值引用 27.智能指针的使用场景确实c++开发的经验很少，面试官问我那几种智能指针的使用场景，答得支支吾吾的，基本上只会说智能管理内存，更安全更方便。还问我shared_ptr跟单例的分别作用场景，为什么在这要用shared_ptr不选择用单例，也没有答好。后面还断网了。 28.对mmo游戏的讨论29.对游戏中UI开发的讨论聊得很开心但是经常断网….. 总结：被狠狠拷打了，面试官一上来就说自己是引擎负责人，然后说会问一些偏引擎跟优化的东西，被问了很多细节跟实操，确实对很多知识还停留在了解层面。本来感觉反问环节是很好拉近距离的时候，结果聊得挺开心的但是经常断网，真的难绷，还不知道是哪边的问题。但是面试官确实给出了非常多的学习方向与内容，问的问题很拓展我的思考，非常有用的一次面试。 电魂游戏：野蛮人2项目组1.对大学一些经历的询问2.介绍项目并且简单介绍技术点3.事件系统的流程4.之前做游戏的一些经历5.行为树的内部运行方式6.二叉树的遍历7.以往的经历中对自己提升最大的事情8.对过去参加过的游戏开发类活动的总结9.构造函数与析构函数10.虚析构函数的作用11.new与malloc12.申请内存会调用哪些底层接口13.是否了解Windows编程14.红黑树的特征15.红黑树的构造过程16.对常见算法的理解，比如贪心与搜索17.挑一个最熟悉的算法讲一下实现与应用场景18.口述BFS并且打印路径19.C#值类型与引用类型20.C#内存管理机制21.GC与CLR22.编译原理23.tcp与udp的区别24.udp如何实现稳定传输25.说一下UnityShader26.后处理的实现与原理27.口述边缘检测的大致shader28.渲染状态的设置29.深度检测与透明度测试30.项目中行为树的详细实现31.对未来的工作规划反问：1.实习负责哪些内容2.项目使用的大致架构总结：面试的内容非常宽泛，但是并不是非常深入，能感觉到项目组会希望你的潜力大一点比较好，面试官也说会希望实习生会的方向多一点，项目中负责的内容主要是看能力。面试官也很温柔，就是因为腾讯会议出了问题所以声音有点小。后面有接近10分钟面试官对我的主动输出，说了项目架构，项目人员情况与团队氛围，最后结束语是hr会联系你的，当时感觉应该是稳了，半小时后hr口头告知通过下周发正式录用，好耶好耶~ 写在最后整个春招的内容大概就是这些了，写这篇博客也是写了半天累死了，不过希望能给大家带来帮助。越面试是会越有经验的，在你回答当前这个问题的时候，你就应该猜到面试官很有可能会从你的回答中去提出下一个问题来挖掘你的深度，所以面试的表现应该始终把握在一个量内，能完整的回答上当前问题，但是不要过于卖弄你的知识面以防被深挖太多从而丢掉原有的分数。同时对自己简历内容的把控跟项目经验也是非常重要的一部分，你知道应该要知道面试官从你的简历上会提问哪些内容，提早做好应对，会让你更加的从容。再就是基础是一切的根基，并且深深地影响着你的面试内容。像西山居的面试官感觉我太小，计网跟操作系统都还不会，所以只能往八股跟项目去问，而网易那边也是因为我不会lua，直接丢失了很核心的竞争力。所以今后的学习方向，也是要从这些踩坑踩出来的经验出发，打好一个计算机学科该有的基础，完善的cpp项目经验以及工程能力，当然还有算法。希望日后能取得不错的成果。","categories":[{"name":"求职","slug":"求职","permalink":"https://wyryyds.github.io/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"春招","slug":"春招","permalink":"https://wyryyds.github.io/tags/%E6%98%A5%E6%8B%9B/"}]}],"categories":[{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/categories/Game-Design/"},{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/categories/UE5/"},{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/categories/Unity/"},{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/categories/C/"},{"name":"C#","slug":"C/C","permalink":"https://wyryyds.github.io/categories/C/C/"},{"name":"求职","slug":"求职","permalink":"https://wyryyds.github.io/categories/%E6%B1%82%E8%81%8C/"}],"tags":[{"name":"Destiny2","slug":"Destiny2","permalink":"https://wyryyds.github.io/tags/Destiny2/"},{"name":"Game Design","slug":"Game-Design","permalink":"https://wyryyds.github.io/tags/Game-Design/"},{"name":"UE5","slug":"UE5","permalink":"https://wyryyds.github.io/tags/UE5/"},{"name":"Lyra","slug":"Lyra","permalink":"https://wyryyds.github.io/tags/Lyra/"},{"name":"C#","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://wyryyds.github.io/tags/Unity/"},{"name":"xlua","slug":"xlua","permalink":"https://wyryyds.github.io/tags/xlua/"},{"name":"ILRuntime","slug":"ILRuntime","permalink":"https://wyryyds.github.io/tags/ILRuntime/"},{"name":"HyBridCLR，热更新","slug":"HyBridCLR，热更新","permalink":"https://wyryyds.github.io/tags/HyBridCLR%EF%BC%8C%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"C++","slug":"C","permalink":"https://wyryyds.github.io/tags/C/"},{"name":"春招","slug":"春招","permalink":"https://wyryyds.github.io/tags/%E6%98%A5%E6%8B%9B/"}]}